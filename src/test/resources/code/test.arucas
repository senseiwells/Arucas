// ./src/test/resources/code/test.arucas

import * from util.Errors;

class Vec2d {
    var x: Number = 0;
    var y: Number = 0;

    static fun zeroVector(): Vec2d {
        return Vec2d.fromScalar(0);
    }

    static fun fromScalar(s: Number): Vec2d {
        return new Vec2d(s, s);
    }

    static fun fromString(string: String): Vec2d {
        list = string.replaceAll('\\[', "").replaceAll('\\]', "").split(', ');
        return new Vec2d(list[0].toNumber(), list[1].toNumber());
    }

    Vec2d(x, y) {
        this.x = x;
        this.y = y;
    }

    Vec2d(list: List) {
        this.x, this.y = list;
    }


    fun setX(x: Number): Vec2d {
        return new Vec2d(x, this.y);
    }

    fun setY(y: Number): Vec2d {
        return new Vec2d(this.x, y);
    }
    //******OPERATORS********

        fun add(v: Vec2d): Vec2d {
            x = this.x + v.x;
            y = this.y + v.y;
            return new Vec2d(x, y);
        }

        operator + (v: Vec2d){
            return this.add(v);
        }

        fun addScalar(s: Number): Vec2d {
            x = this.x + s;
            y = this.y + s;
            return new Vec2d(x, y);
        }

        fun sub(v: Vec2d): Vec2d {
            x = this.x - v.x;
            y = this.y - v.y;
            return new Vec2d(x, y);
        }

        operator - (v: Vec2d){
            return this.sub(v);
        }

        fun subScalar(s: Number): Vec2d {
            x = this.x - s;
            y = this.y - s;
            return new Vec2d(x, y);
        }

        fun multiply(v: Vec2d): Vec2d {
            x = this.x * v.x;
            y = this.y * v.y;
            return new Vec2d(x, y);
        }

        operator * (v: Vec2d){
            return this.multiply(v);
        }

        fun multiplyScalar(s: Number): Vec2d {
            x = this.x * s;
            y = this.y * s;
            return new Vec2d(x, y);
        }

        fun divide(v: Vec2d): Vec2d {
            if (v.x == 0 || v.y == 0) {
                return this;
            }
            return new Vec2d(this.x / v.x, this.y / v.y);
        }

        operator / (v: Vec2d){
            return this.divide(v);
        }

        fun divideScalar(s: Number): Vec2d {
            if (s == 0) {
                return this;
            }
            return this.multiply(1 / s);
        }

        fun equals(v): Boolean {
            return v.instanceOf(Vec2d.type) && (v.x == this.x) && (v.y == this.y);
        }
        operator == (other): Boolean {
            return this.equals(other);
        }

        operator [] (index: Number): Number {
            if (index == 0) {
                return this.x;
            } else if (index == 1) {
                return this.y;
            } else {
                throw new Error("Index "+index +" out of bounds for Vec2d");
            }
        }
    //***********************
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    fun angle(): Number {
        return Math.arctan(this.y / this.x);
    }

    fun cross(v: Vec2d): Number {
        return this.x * v.y - this.y * v.x;
    }

    fun distanceTo(v): Number {
        return Math.sqrt(this.distanceToSquared(v));
    }

    fun distanceToSquared(v): Number {
        dx = this.x - v.x;
        dy = this.y - v.y;
        return dx * dx + dy * dy;
    }


    fun dot(v): Number {
        return this.x * v.x + this.y * v.y;
    }

    fun length(): Number {
        return Math.sqrt(this.lengthSq());
    }

    fun lengthSq(): Number {
        return this.x * this.x + this.y * this.y;
    }


    fun negate(): Vec2d {
        return this.multiplyScalar(-1);
    }

    fun normalize(): Vec2d {
        l = this.length();
        if (l == 0) {
            return this;
        }

        return this.divideScalar(this.length());
    }

    /*
     * Angle in radians
     */
    fun rotate(angle: Number, centre: Vec2d): Vec2d {
        x = this.x - centre.x;
        y = this.y - centre.y;
        return new Vec2d(x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle));
    }
    fun rotate(angle: Number): Vec2d {
        return new Vec2d(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
    }

    /**
     * Returns new Vector
     */
    fun setLength(length: Number): Vec2d {
        return this.normalize().multiply(length);
    }


    fun floor(): Vec2d {
        return new Vec2d(Math.floor(this.x), Math.floor(this.y));
    }


    fun hashCode(): Number {
        return 31 * (31 * this.x + this.y);
    }

    fun toString(): String {
        return "[" + this.x + ", " + this.y + "]";
    }

    fun copy(): Vec2d {
        return new Vec2d(this.x, this.y);
    }

    fun toList(): List{
        return [this.x, this.y];
    }


    /**
     * -pi to pi
     */
    static fun angleBetween(v1: Vec2d, v2: Vec2d): Number {
        // -2pi to 2pi
        between = v1.angle() - v2.angle();
        if (between > Math.pi) {
            between = between - 2 * Math.pi;
        } else if (between <= -Math.pi) {
            between = between + 2 * Math.pi;
        }
        return between;
    }
}

class Vec3d {
    var x: Number = 0;
    var y: Number = 0;
    var z: Number = 0;

    static fun zeroVector(): Vec3d {
        return Vec3d.fromScalar(0);
    }

    static fun fromScalar(s: Number): Vec3d {
        return new Vec3d(s, s, s);
    }

    static fun fromString(string: String): Vec3d {
        list = string.replaceAll('\\[', "").replaceAll('\\]', "").split(', ');
        return new Vec3d(list[0].toNumber(), list[1].toNumber(), list[2].toNumber());
    }

    Vec3d(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    Vec3d(list: List) {
        this.x, this.y, this.z = list;
    }



    fun setX(x: Number): Vec3d {
        return new Vec3d(x, this.y, this.z);
    }

    fun setY(y: Number): Vec3d {
        return new Vec3d(this.x, y, this.z);
    }

    fun setZ(z: Number): Vec3d {
        return new Vec3d(this.x, this.y, z);
    }


    //******OPERATORS********

        fun add(v: Vec3d): Vec3d {
            return new Vec3d(this.x + v.x, this.y + v.y, this.z + v.z);
        }

        operator + (v: Vec3d){
            return this.add(v);
        }

        fun addScalar(s: Number): Vec3d {
            return new Vec3d(this.x + s, this.y + s, this.z + s);
        }


        fun sub(v: Vec3d): Vec3d {
            return new Vec3d(this.x - v.x, this.y - v.y, this.z - v.z);
        }

        operator - (v: Vec3d){
            return this.sub(v);
        }

        fun subScalar(s: Number): Vec3d {
            return new Vec3d(this.x - s, this.y - s, this.z + s);
        }

        fun multiply(v: Vec3d): Vec3d {
            return new Vec3d(this.x * v.x, this.y * v.y, this.z * v.z);
        }

        operator * (v: Vec3d){
            return this.multiply(v);
        }

        fun multiplyScalar(s: Number): Vec3d {
            return new Vec3d(this.x * s, this.y * s, this.z * s);
        }

        fun divide(v: Vec3d): Vec3d {
            if (v.x == 0 || v.y == 0 || v.z ==0) {
                return this;
            }
            return new Vec3d(this.x / v.x, this.y / v.y, this.z / v.z);
        }

        operator / (v: Vec3d){
            return this.divide(v);
        }

        fun divideScalar(s: Number): Vec3d {
            if (s == 0) {
                return this;
            }
            return new Vec3d(this.x / s, this.y / s, this.z / s);
        }

        fun equals(v): Boolean {
            return v.instanceOf(Vec3d.type) && (v.x == this.x) && (v.y == this.y) && (v.s == this.s);
        }
        operator == (other): Boolean {
            return this.equals(other);
        }

        operator ^ (s: Number): Vec3d {
            return new Vec3d(this.x^s, this.y^s, this.z^s);
        }

        operator [] (index: Number): Number {
            if (index == 0) {
                return this.x;
            } else if (index == 1) {
                return this.y;
            } else if (index == 2) {
                return this.z;
            } else {
                throw new IndexError(index, 2);
            }
        }
    //***********************
    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    fun angle() {
        return new PolarCoordinates3d.fromVec3d(this);
    }

    fun cross(v: Vec3d): Number {
        x = this[1] * v[2] - this[2] * v[1];
        y = this[2] * v[0] - this[0] * v[2];
        z = this[0] * v[1] - this[1] * v[0];
        return new Vec3d(x, y, z);
    }

    fun distanceTo(v: Vec3d): Number {
        return Math.sqrt(this.distanceToSquared(v));
    }

    fun distanceToSquared(v: Vec3d): Number {
        dx = this.x - v.x;
        dy = this.y - v.y;
        dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }


    fun dot(v): Number {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    fun length(): Number {
        return Math.sqrt(this.lengthSq());
    }

    fun lengthSq(): Number {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }


    fun negate(): Vec3d {
        return this.multiplyScalar(-1);
    }

    fun normalize(): Vec3d {
        l = this.length();
        if (l == 0) {
            return this;
        }

        return this.divide(this.length());
    }

    /*
     * Angle in radians
    */

    fun rotate(angle: Number, axis: Vec3d): Vec3d {
        axis = axis.normalize();
        rotationMatrix = Matrix2d.roation(angle, axis);
        return new Vec3d(rotationMatrix.multiply(Matrix2d.columnVector(axis).getColumn(0)));
    }

    /*
     * Returns new Vector
     */
    fun setLength(length: Number): Vec3d {
        return this.normalize().multiply(length);
    }

    fun floor(): Vec3d {
        return new Vec3d(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
    }

    fun hashCode(): Number {
        return 31 * (31 * this.x + this.y + this.z);
    }

    fun toString(): String {
        return "[" + this.x + ", " + this.y + ", " + this.z + "]";
    }

    fun copy(): Vec3d {
        return new Vec3d(this.x, this.y, this.z);
    }

    fun toList(): List{
        return [this.x, this.y, this.z];
    }

    /**
     * -pi to pi
     */
    static fun angleBetween(v1: Vec3d, v2: Vec3d) {
        // -2pi to 2pi
        between = v1.angle() - v2.angle();
        if (between > Math.pi) {
            between = between - 2 * Math.pi;
        } else if (between <= -Math.pi) {
            between = between + 2 * Math.pi;
        }
        return between;
    }
}

class Matrix2d{

    var rows: Number;
    var columns: Number;
    var data: List;


    static fun fromScalar(s: Number, rows: Number, columns: Number): Matrix2d{
        data = [];
        for(i = 0; i<rows; i++){
            data.append([]);
            for(j; j<columns; j++){
                data[i].append(s);
            }
        }
        return new Matrix2d(data);
    }

    static fun zero(rows: Number, columns: Number): Matrix2d{
        data = [];
        for(i = 0; i<rows; i++){
            data.append([]);
            for(j; j<columns; j++){
                data[i].append(0);
            }
        }
        return new Matrix2d(data);
    }

    static fun identity(s: Number): Matrix2d{
        data = [];
        for(i = 0; i<s; i++){
            data.append([]);
            for(j; j<s; j++){
                if(i==j)
                    data[i].append(1);
                else
                    data[i].append(0);
            }
        }
        return new Matrix2d(data);
    }

    static fun columnVector(list: List): Matrix2d{
        data = [];
        for(i = 0; i<list.length(); i++){
            data[i] = [list[i]];
        }
        return data;
    }

    static fun rotation(angle: Number, direction: Vec3d): Matrix2d{
        ux, uy, uz = direction.toList();
        return new Matrix2d([
            [Math.cos(angle) + ux^2(1 - Math.cos(angle)), ux * uy * (1 - Math.cos(angle)) - uz * Math.sin(angle), ux * uz * (1 - Math.cos(angle)) + uy * Math.sin(angle)],
            [uy * ux * (1 - Math.cos(angle)) + uz * Math.sin(angle), Math.cos(angle) + uy^2 * (1 - Math.cos(angle)), uy * uz * (1 - Math.cos(angle)) - ux * Math.sin(angle)],
            [uz * ux * (1 - Math.cos(angle)) - uy * Math.sin(angle), uz * uy * (1 - Math.cos(angle)) + ux * Math.sin(angle), Math.cos(angle) + uz^2 * (1 - Math.cos(angle))]
            ]);
    }

    Matrix2d(list: List){
        for(i = 0; i<rows; i++){
            for(j; j<columns; j++){
                if(Type.of(list[i][j]).getName()!="Number")
                    throw new UnsupportedError("All arguments must be numbers to construct a vector");
            }
        }
        this.rows = list.length();
        this.columns = list[0].length();
        this.data = list;
    }

    fun setValue(i: Number, j: Number, v: Number): Boolean{
        if(i>rows && j > columns){
            return false;
        }
        this.data[i][j] = v;
        return true;
    }

    fun getValue(i: Number, j: Number): Number{
        if(i>rows && j > columns){
            return null;
        }
        return this.data[i][j];
    }

    fun getRows(): Number{
        return this.rows;
    }

    fun getColumns(): Number{
        return this.columns;
    }

    fun getRow(i: Number): List{
        if(i<this.rows)
            return this.data[i];
        return null;
    }

    fun getColumn(j: Number): List{
        if(j<this.columns){
            column = [];
            for(i = 0; i< this.columns; i++){
                column.append(this.getValue(i, j));
            }
            return column;
        }
        return null;
    }

    fun add(m: Matrix2d): Matrix2d{
        data = [];
        if(this.rows == m.rows && this.columns == m.columns){
            for(i = 0; i< this.rows; i++){
                data.append([]);
                for(j = 0; j< this.columns; j++){
                    data[i].append(this.getValue(i, j) + m.getValue(i, j));
                }
            }
        }
        return new Matrix2d(data);
    }

    operator + (m: Matrix2d): Matrix2d{
        return this.add(m);
    }

    fun addScalar(s: Number): Matrix2d{
        data = [];
        for(i = 0; i< this.rows; i++){
            data.append([]);
            for(j = 0; j< this.columns; j++){
                data[i].append(this.getValue(i, j) + s);
            }
        }
        return new Matrix2d(data);
    }

    fun sub(m: Matrix2d): Matrix2d{
        data = [];
        if(this.rows == m.rows && this.columns == m.columns){
            for(i = 0; i< this.rows; i++){
                data.append([]);
                for(j = 0; j< this.columns; j++){
                    data[i].append(this.getValue(i, j) - m.getValue(i, j));
                }
            }
        }
        return new Matrix2d(data);
    }

    operator - (m: Matrix2d): Matrix2d{
        return this.sub(m);
    }

    fun subScalar(s: Number): Matrix2d{
        data = [];
        for(i = 0; i< this.rows; i++){
            data.append([]);
            for(j = 0; j< this.columns; j++){
                data[i].append(this.getValue(i, j) - s);
            }
        }
        return new Matrix2d(data);
    }

    fun multiply(m: Matrix2d): Matrix2d{
        if(this.columns == m.rows){
            data = [];
            for(i = 0; i< this.rows; i++){
                data.append([]);
                for(j = 0; j< this.columns; j++){
                    data[i].append(Vector.dotProduct(this.getRow(i),m.getColumn(j)));
                }
            }
            return new Matrix2d(data);
        }
        return null;

    }

    operator * (m: Matrix2d): Matrix2d{
        return this.multiply(m);
    }

    fun multiplyScalar(s: Number): Matrix2d{
        data = [];
        for(i = 0; i< this.rows; i++){
            data.append([]);
            for(j = 0; j< this.columns; j++){
                data[i].append(this.getValue(i, j) * s);
            }
        }
        return new Matrix2d(data);
    }

    operator [] (index: Number){
        return new Vector(this.data[index]);
    }

    fun determinant(): Number{
        if(this.rows == this.columns){
            if(this.rows ==2){
                return this.getValue(0, 0)*this.getValue(1, 1)-this.getValue(0, 1)*this.getValue(1, 0);
            }
            else{
                result = 0;
                minus = true;
                i = 0;
                foreach(matrix : Matrix2d.determinantSubMatrices(this)){
                    if(i = 0){
                        result = this.getValue(i,0)*matrix.determinant();
                        i++;
                    }
                    else{
                        if(minus){
                            result = result - this.getValue(i,0)*matrix.determinant();
                            minus = false;
                        }
                        else{
                            result = result + this.getValue(i,0)*matrix.determinant();
                            minus = true;
                        }
                    }
                }
                return result;
            }
        }
    }
    static fun determinantSubMatrices(m: Matrix2d): List{
        list = [];
        for(a = 0; a<m.columns; a++){
            data = [];
            n = 0;
            for(i = 0; i<m.columns; i++){
                if(i!=a){
                    data.append([]);
                    for(j = 0; j<m.rows; j++){
                        if(j!=a){
                            data[n].append(m.getValue(i, j));
                        }
                    }
                    n++;
                }
            }
            list.append(new Matrix2d(data));
        }
        return list;
    }

    fun inverse(): Matrix2d{
        if(this.rows==this.columns){
            b = Matrix2d.identity(this.rows);
            for (i = 0; i < this.rows; i++) {
                max = i;
                for (j = i + 1; j < n; j++) {
                    if (Math.abs(a[j][i]) > Math.abs(a[max][i])) {
                        max = j;
                    }
                }

                temp = this.data[i];
                this.data[i] = this.data[max];
                this.data[max] = temp;

                temp = b.data[i];
                b.data[i] = b.data[max];
                b.data[max] = temp;

                div = this.data[i][i];
                if(div == 0){
                    return null;
                }
                for (j = 0; j < n; j++) {
                    this.data[i][j] = this.getValue(i, j) / div;
                    b.data[i][j] = b.getValue(i, j) / div;
                }

                for (j = 0; j < n; j++) {
                    if (j != i) {
                        sub = a[j][i];
                        for (k = 0; k < n; k++) {
                            this.data[j][k] = this.getValue(j, k) - this.getValue(i, k) * sub;
                            b.data[j][k] = b.getValue(j, k) - b.getValue(i, k) * sub;
                        }
                    }
                }
            }
            return b;
        }
        return null;
    }
    fun subMatrix(is: Number, js: Number, ie: Number, je: Number): Matrix2d{
        data = [];
        if(is<=ie && ie<this.rows && js<=je && je < this.columns){
            for(i = is; i < ie; i++){
                data.append([]);
                for(j = js; j < je; j++){
                    data[i-is].append(this.getValue(i, j));
                }
            }
            return new Matrix2d(data);
        }
        return null;
    }
}


class Vector{

    static fun dotProduct(listA: List, listB: List){
        dotProduct = 0;
        if(listA.length()==listB.length()){
            for(i = 0; i<listA.length();i++){
                dotProduct = dotProduct + listA[i] * listB[i];
            }
        }
        return dotProduct;
    }

    var length: Number;
    var data: List;

    static fun zeroVector(length: Number): Vector {
        return Vector.fromScalar(0);
    }

    static fun fromScalar(length: Number, s: Number): Vector {
        data = [];
        for(i = 0; i < length; i++){
            data.append(s);
        }
        return new Vector(data);
    }

    static fun fromString(string: String): Vector {
        list = string.replaceAll('\\[', "").replaceAll('\\]', "").split(', ');
        data = [];
        for(i = 0; i < length; i++){
            data.append(list[i].toNumber());
        }
        return new Vector(data);
    }

    Vector(args...) {
        foreach(arg: args){
            if(Type.of(arg).getName()!="Number")
                throw new UnsupportedError("All arguments must be numbers to construct a vector");
        }
        this.data = args;
        this.length = args.length;
    }

    Vector(list: List) {
        foreach(item: list){
            if(Type.of(item).getName()!="Number")
                throw new UnsupportedError("All list elements must be numbers to construct a vector");
        }
        this.data = list;
        this.length = list.length;
    }

    fun set(s: Number, index: Number): Vector {
        if(index<this.length){
            return new Vector(this.data.insert(s, index));
        }
        throw new IndexError(index, this.length-1);
    }


    //******OPERATORS********

        fun add(v: Vector): Vector {
            if(this.length==v.length){
                data = [];
                for(i = 0; i<this.length; i++){
                    data.append = this[i] + v[i];
                }
                return new Vector(data);
            }
            throw new IllegalArgumentError("The length of the 2 vectors does not match!");
        }

        operator + (v: Vector){
            return this.add(v);
        }

        fun addScalar(s: Number): Vector {
            data = [];
            for(i = 0; i<this.length; i++){
                data.append = this[i] + s;
            }
            return new Vector(data);
        }


        fun sub(v: Vector): Vector {
            if(this.length==v.length){
                data = [];
                for(i = 0; i<this.length; i++){
                    data.append = this[i] - v[i];
                }
                return new Vector(data);
            }
            throw new IllegalArgumentError("The length of the 2 vectors does not match!");
        }

        operator - (v: Vector){
            return this.sub(v);
        }

        fun subScalar(s: Number): Vector {
            data = [];
            for(i = 0; i<this.length; i++){
                data.append = this[i] - s;
            }
            return new Vector(data);
        }

        fun multiply(v: Vector): Vector {
            if(this.length==v.length){
                data = [];
                for(i = 0; i<this.length; i++){
                    data.append = this[i] * v[i];
                }
                return new Vector(data);
            }
            throw new IllegalArgumentError("The length of the 2 vectors does not match!");
        }

        operator * (v: Vector){
            return this.multiply(v);
        }

        fun multiplyScalar(s: Number): Vector {
            data = [];
            for(i = 0; i<this.length; i++){
                data.append = this[i] * s;
            }
            return new Vector(data);
        }

        fun divide(v: Vector): Vector {
            if(this.length==v.length){
                data = [];
                for(i = 0; i<this.length; i++){
                    data.append = this[i] / v[i];
                }
                return new Vector(data);
            }
            throw new IllegalArgumentError("The length of the 2 vectors does not match!");
        }

        operator / (v: Vector){
            return this.divide(v);
        }

        fun divideScalar(s: Number): Vector {
            data = [];
            for(i = 0; i<this.length; i++){
                data.append = this[i] / s;
            }
            return new Vector(data);
        }

        fun equals(v): Boolean {
            return v.instanceOf(Vector.type) && (v.x == this.x) && (v.y == this.y) && (v.s == this.s);
        }
        operator == (other): Boolean {
            return this.equals(other);
        }

        operator ^ (s: Number): Vector {
            data = [];
            for(i = 0; i<this.length; i++){
                data.append = this[i] ^ s;
            }
            return new Vector(data);
        }

        operator [] (index: Number): Number {
            if(index<this.length){
                return this.data[index];
            }
            throw new IndexError(index, this.length-1);
        }
    //***********************


    fun distanceTo(v: Vector): Number {
        return Math.sqrt(this.distanceToSquared(v));
    }

    fun distanceToSquared(v: Vector): Number {
        if(this.length==v.length){
            result = 0;
            for(i = 0; i<this.length; i++){
                d = this[i] - v[i];
                result = result + d^2;
            }
            return result;
        }
        throw new IllegalArgumentError("The length of the 2 vectors does not match!");
    }


    fun dot(v: Vector): Number {
        if(this.length==v.length){
            result = 0;
            for(i = 0; i<this.length; i++){
                result = result + this[i]*v[i];
            }
            return result;
        }
        throw new IllegalArgumentError("The length of the 2 vectors does not match!");
    }

    fun length(): Number {
        return Math.sqrt(this.lengthSq());
    }

    fun lengthSq(): Number {
        result = 0;
        for(i = 0; i<this.length; i++){
            result = result + this.data[i]^2;
        }
        return result;
    }


    fun negate(): Vector {
        return this.multiplyScalar(-1);
    }

    fun normalize(): Vector {
        l = this.length();
        if (l == 0) {
            return this;
        }
        return this.divide(this.length());
    }

    /*
     * Returns new Vector
     */
    fun setLength(length: Number): Vector {
        return this.normalize().multiply(length);
    }

    fun floor(): Vector {
        return new Vector(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
    }

    fun hashCode(): Number {
        result = 0;
        for(i = 0; i<this.length; i++){
            result = result + this.data[i];
        }
        return 31 * (31 * result);
    }

    fun toString(): String {
        string = "[";
        for(i = 0; i<this.length; i++){
            string = string + this[i] + ", ";
        }
        return string + "]";
    }

    fun copy(): Vector {
        return new Vector(this.data);
    }

    fun toList(): List{
        return this.data;
    }
}

class PolarCoordinates3d {
    var angleZ: Number = 0;
    var angleXY: Number = 0;
    var r: Number = 0;

    PolarCoordinates3d(vec: Vec3d){
        this.angleZ = Math.arctan(Math.sqrt(vec.x ^ 2 + vec.y ^ 2) / vec.z);
        this.angleXY = Math.arcsin(vec.y / vec.x);
        this.r = Math.sqrt(vec.x ^ 2 + vec.y ^ 2 + vec.z ^ 2);
    }

    PolarCoordinates3d(angleZ: Number, angleXY: Number, r: Number){
        this.angleZ = angleZ;
        this.angleXY = angleXY;
        this.r = r;
    }
    PolarCoordinates3d(): this(0,0,0){
    }

    fun getAngleZ(): Number {
        return this.angleZ;
    }
    fun getAngleXY(): Number {
        return this.angleXY;
    }
    fun getRadius(): Number {
        return this.r;
    }

    fun setAngleZ(): Number {
        return new PolarCoordinates3d(angleZ, this.angleXY, this.r);
    }
    fun setAngleXY(): Number {
        return new PolarCoordinates3d(this.angleZ, angleXY, this.r);
    }
    fun setRadius(): Number {
        return new PolarCoordinates3d(this.angleZ, this.angleXY, r);
    }

    fun toCartesianCoordinates(): Vec3d {
        x = this.r * Math.sin(this.angleZ)*Math.cos(this.angleXY);
        y = this.r * Math.sin(this.angleZ)*Math.sin(this.angleXY);
        z = this.r * Math.cos(this.angleZ);
        return new Vec3d(x, y, z);
    }

    operator + (pol: PolarCoordinates3d){
        return new PolarCoordinates3d(this.angleZ + pol.angleZ, this.angleXY + pol.angleXY, this.r + pol.r);
    }

    operator - (pol: PolarCoordinates3d){
        return new PolarCoordinates3d(this.angleZ - pol.angleZ, this.angleXY - pol.angleXY, this.r - pol.r);
    }

}

class PolarCoordinates2d {
    var angleZ: Number = 0;
    var angleXY: Number = 0;
    var r: Number = 0;

    PolarCoordinates2d(vec: Vec2d){
        angle = Math.arctan(vec.y / vec.x);
        if (vec.x < 0){
            angle = angle + Math.pi;
        }
        if (angle.isNaN()) {
            angle = 0;
        }
        this.angle = angle;
        this.r = Math.sqrt(vec.x ^ 2 + vec.y ^ 2);
    }

    PolarCoordinates2d(angle: Number, r: Number){
        this.angle = angle;
        this.r = r;
    }
    PolarCoordinates2d(): this(0,0){
    }

    fun getAngle(): Number {
        return this.angle;
    }
    fun getRadius(): Number {
        return this.r;
    }

    fun setAngle(angle: Number): PolarCoordinates2d {
        return new PolarCoordinates2d(angle, this.r);
    }
    fun setRadius(): PolarCoordinates2d {
        return new PolarCoordinates2d(this.angle, r);
    }
    fun toCartesianCoordinates(): Vec3d {
        x = r * Math.cos(angle);
        y = r * Math.sin(angle);
        return new Vec2d(x, y);
    }

    operator + (pol: PolarCoordinates2d){
        return new PolarCoordinates3d(this.angle + pol.angle, this.r + pol.r);
    }

    operator - (pol: PolarCoordinates2d){
        return new PolarCoordinates3d(this.angle - pol.angle, this.r - pol.r);
    }

}

enum NoiseQuality {
	/**
	 *  Generates coherent noise quickly.  When a coherent-noise function with
	 *	this quality setting is used to generate a bump-map image, there are
	 *  noticeable "creasing" artifacts in the resulting image.  This is
	 *  because the derivative of that function is discontinuous at integer
	 *  boundaries.
	 */
	FAST,
	/**
	 * Generates standard-quality coherent noise. When a coherent-noise function
	 * with this quality setting is used to generate a bump-map image, there are
	 * some minor "creasing" artifacts in the resulting image. This is because
	 * the second derivative of that function is discontinuous at integer
	 * boundaries.
	 */
	STANDARD,
	/**
	 * Generates the best-quality coherent noise. When a coherent-noise function
	 * with this quality setting is used to generate a bump-map image, there are
	 * no "creasing" artifacts in the resulting image. This is because the first
	 * and second derivatives of that function are continuous at integer
	 * boundaries.
	 */
	BEST
}

class NoiseUtils {
	static var SQRT_2 = 1.4142135623730950488;
	static var SQRT_3 = 1.7320508075688772935;
	static var DEG_TO_RAD = Math.pi / 180.0;
	static var RAD_TO_DEG = 1.0 / this.DEG_TO_RAD;

	/**
	 * Performs cubic interpolation between two values bound between two other
	 * values
	 *
	 * @param n0 the value before the first value
	 * @param n1 the first value
	 * @param n2 the second value
	 * @param n3 the value after the second value
	 * @param a the alpha value
	 * @return the interpolated value
	 */
	static fun CubicInterp(n0: Number, n1: Number, n2: Number, n3: Number, a: Number): Number {
		p = (n3 - n2) - (n0 - n1);
		q = (n0 - n1) - p;
		r = n2 - n0;

		return p * a * a * a + q * a * a + r * a + n1;
	}

	/**
	 * Maps a value onto a cubic S-Curve
	 *
	 * @param a the value to map onto a S-Curve
	 * @return the mapped value
	 */
	static fun SCurve3(a: Number): Number {
		return (a * a * (3.0 - 2.0 * a));
	}

	/**
	 * maps a value onto a quitnic S-Curve
	 *
	 * @param a the value to map onto a quitic S-curve
	 * @return the mapped value
	 */
	static fun SCurve5(a: Number): Number {
		a3 = a * a * a;
		a4 = a3 * a;
		a5 = a4 * a;
		return (6.0 * a5) - (15.0 * a4) + (10.0 * a3);
	}

	static fun LatLonToXYZ(latitude: Number, longitude: Number): Vec3d {
		r = Math.cos(Math.toRadians(latitude));
		x = r * Math.cos(Math.toRadians(longitude));
		y = Math.sin(Math.toRadians(latitude));
		z = r * Math.sin(Math.toRadians(longitude));
		return new Vec3d (x, y, z);
	}

	/**
	 *
	 *
	 * A table of 256 random normalized vectors. Each row is an (x, y, z, 0)
	 * coordinate. The 0 is used as padding so we can use bit shifts to index
	 * any row in the table. These vectors have an even statistical
	 * distribution, which improves the quality of the coherent noise generated
	 * by these vectors. For more information, see "GPU Gems", Chapter 5 -
	 * Implementing Improved Perlin Noise by Ken Perlin, specifically page 76.
	 *
	 */
	static var RandomVectors = [-0.763874, -0.596439, -0.246489, 0.0, 0.396055, 0.904518, -0.158073, 0.0, -0.499004, -0.8665, -0.0131631, 0.0, 0.468724, -0.824756, 0.316346, 0.0, 0.829598, 0.43195, 0.353816, 0.0, -0.454473, 0.629497, -0.630228, 0.0, -0.162349, -0.869962, -0.465628, 0.0, 0.932805, 0.253451, 0.256198, 0.0, -0.345419, 0.927299, -0.144227, 0.0, -0.715026, -0.293698, -0.634413, 0.0, -0.245997, 0.717467, -0.651711, 0.0, -0.967409, -0.250435, -0.037451, 0.0, 0.901729, 0.397108, -0.170852, 0.0, 0.892657, -0.0720622, -0.444938, 0.0, 0.0260084, -0.0361701, 0.999007, 0.0, 0.949107, -0.19486, 0.247439, 0.0, 0.471803, -0.807064, -0.355036, 0.0, 0.879737, 0.141845, 0.453809, 0.0, 0.570747, 0.696415, 0.435033, 0.0, -0.141751, -0.988233, -0.0574584, 0.0, -0.58219, -0.0303005, 0.812488, 0.0, -0.60922, 0.239482, -0.755975, 0.0, 0.299394, -0.197066, -0.933557, 0.0, -0.851615, -0.220702, -0.47544, 0.0, 0.848886, 0.341829, -0.403169, 0.0, -0.156129, -0.687241, 0.709453, 0.0, -0.665651, 0.626724, 0.405124, 0.0, 0.595914, -0.674582, 0.43569, 0.0, 0.171025, -0.509292, 0.843428, 0.0, 0.78605, 0.536414, -0.307222, 0.0, 0.18905, -0.791613, 0.581042, 0.0, -0.294916, 0.844994, 0.446105, 0.0, 0.342031, -0.58736, -0.7335, 0.0, 0.57155, 0.7869, 0.232635, 0.0, 0.885026, -0.408223, 0.223791, 0.0, -0.789518, 0.571645, 0.223347, 0.0, 0.774571, 0.31566, 0.548087, 0.0, -0.79695, -0.0433603, -0.602487, 0.0, -0.142425, -0.473249, -0.869339, 0.0, -0.0698838, 0.170442, 0.982886, 0.0, 0.687815, -0.484748, 0.540306, 0.0, 0.543703, -0.534446, -0.647112, 0.0, 0.97186, 0.184391, -0.146588, 0.0, 0.707084, 0.485713, -0.513921, 0.0, 0.942302, 0.331945, 0.043348, 0.0, 0.499084, 0.599922, 0.625307, 0.0, -0.289203, 0.211107, 0.9337, 0.0, 0.412433, -0.71667, -0.56239, 0.0, 0.87721, -0.082816, 0.47291, 0.0, -0.420685, -0.214278, 0.881538, 0.0, 0.752558, -0.0391579, 0.657361, 0.0, 0.0765725, -0.996789, 0.0234082, 0.0, -0.544312, -0.309435, -0.779727, 0.0, -0.455358, -0.415572, 0.787368, 0.0, -0.874586, 0.483746, 0.0330131, 0.0, 0.245172, -0.0838623, 0.965846, 0.0, 0.382293, -0.432813, 0.81641, 0.0, -0.287735, -0.905514, 0.311853, 0.0, -0.667704, 0.704955, -0.239186, 0.0, 0.717885, -0.464002, -0.518983, 0.0, 0.976342, -0.214895, 0.0240053, 0.0, -0.0733096, -0.921136, 0.382276, 0.0, -0.986284, 0.151224, -0.0661379, 0.0, -0.899319, -0.429671, 0.0812908, 0.0, 0.652102, -0.724625, 0.222893, 0.0, 0.203761, 0.458023, -0.865272, 0.0, -0.030396, 0.698724, -0.714745, 0.0, -0.460232, 0.839138, 0.289887, 0.0, -0.0898602, 0.837894, 0.538386, 0.0, -0.731595, 0.0793784, 0.677102, 0.0, -0.447236, -0.788397, 0.422386, 0.0, 0.186481, 0.645855, -0.740335, 0.0, -0.259006, 0.935463, 0.240467, 0.0, 0.445839, 0.819655, -0.359712, 0.0, 0.349962, 0.755022, -0.554499, 0.0, -0.997078, -0.0359577, 0.0673977, 0.0, -0.431163, -0.147516, -0.890133, 0.0, 0.299648, -0.63914, 0.708316, 0.0, 0.397043, 0.566526, -0.722084, 0.0, -0.502489, 0.438308, -0.745246, 0.0, 0.0687235, 0.354097, 0.93268, 0.0, -0.0476651, -0.462597, 0.885286, 0.0, -0.221934, 0.900739, -0.373383, 0.0, -0.956107, -0.225676, 0.186893, 0.0, -0.187627, 0.391487, -0.900852, 0.0, -0.224209, -0.315405, 0.92209, 0.0, -0.730807, -0.537068, 0.421283, 0.0, -0.0353135, -0.816748, 0.575913, 0.0, -0.941391, 0.176991, -0.287153, 0.0, -0.154174, 0.390458, 0.90762, 0.0, -0.283847, 0.533842, 0.796519, 0.0, -0.482737, -0.850448, 0.209052, 0.0, -0.649175, 0.477748, 0.591886, 0.0, 0.885373, -0.405387, -0.227543, 0.0, -0.147261, 0.181623, -0.972279, 0.0, 0.0959236, -0.115847, -0.988624, 0.0, -0.89724, -0.191348, 0.397928, 0.0, 0.903553, -0.428461, -0.00350461, 0.0, 0.849072, -0.295807, -0.437693, 0.0, 0.65551, 0.741754, -0.141804, 0.0, 0.61598, -0.178669, 0.767232, 0.0, 0.0112967, 0.932256, -0.361623, 0.0, -0.793031, 0.258012, 0.551845, 0.0, 0.421933, 0.454311, 0.784585, 0.0, -0.319993, 0.0401618, -0.946568, 0.0, -0.81571, 0.551307, -0.175151, 0.0, -0.377644, 0.00322313, 0.925945, 0.0, 0.129759, -0.666581, -0.734052, 0.0, 0.601901, -0.654237, -0.457919, 0.0, -0.927463, -0.0343576, -0.372334, 0.0, -0.438663, -0.868301, -0.231578, 0.0, -0.648845, -0.749138, -0.133387, 0.0, 0.507393, -0.588294, 0.629653, 0.0, 0.726958, 0.623665, 0.287358, 0.0, 0.411159, 0.367614, -0.834151, 0.0, 0.806333, 0.585117, -0.0864016, 0.0, 0.263935, -0.880876, 0.392932, 0.0, 0.421546, -0.201336, 0.884174, 0.0, -0.683198, -0.569557, -0.456996, 0.0, -0.117116, -0.0406654, -0.992285, 0.0, -0.643679, -0.109196, -0.757465, 0.0, -0.561559, -0.62989, 0.536554, 0.0, 0.0628422, 0.104677, -0.992519, 0.0, 0.480759, -0.2867, -0.828658, 0.0, -0.228559, -0.228965, -0.946222, 0.0, -0.10194, -0.65706, -0.746914, 0.0, 0.0689193, -0.678236, 0.731605, 0.0, 0.401019, -0.754026, 0.52022, 0.0, -0.742141, 0.547083, -0.387203, 0.0, -0.00210603, -0.796417, -0.604745, 0.0, 0.296725, -0.409909, -0.862513, 0.0, -0.260932, -0.798201, 0.542945, 0.0, -0.641628, 0.742379, 0.192838, 0.0, -0.186009, -0.101514, 0.97729, 0.0, 0.106711, -0.962067, 0.251079, 0.0, -0.743499, 0.30988, -0.592607, 0.0, -0.795853, -0.605066, -0.0226607, 0.0, -0.828661, -0.419471, -0.370628, 0.0, 0.0847218, -0.489815, -0.8677, 0.0, -0.381405, 0.788019, -0.483276, 0.0, 0.282042, -0.953394, 0.107205, 0.0, 0.530774, 0.847413, 0.0130696, 0.0, 0.0515397, 0.922524, 0.382484, 0.0, -0.631467, -0.709046, 0.313852, 0.0, 0.688248, 0.517273, 0.508668, 0.0, 0.646689, -0.333782, -0.685845, 0.0, -0.932528, -0.247532, -0.262906, 0.0, 0.630609, 0.68757, -0.359973, 0.0, 0.577805, -0.394189, 0.714673, 0.0, -0.887833, -0.437301, -0.14325, 0.0, 0.690982, 0.174003, 0.701617, 0.0, -0.866701, 0.0118182, 0.498689, 0.0, -0.482876, 0.727143, 0.487949, 0.0, -0.577567, 0.682593, -0.447752, 0.0, 0.373768, 0.0982991, 0.922299, 0.0, 0.170744, 0.964243, -0.202687, 0.0, 0.993654, -0.035791, -0.106632, 0.0, 0.587065, 0.4143, -0.695493, 0.0, -0.396509, 0.26509, -0.878924, 0.0, -0.0866853, 0.83553, -0.542563, 0.0, 0.923193, 0.133398, -0.360443, 0.0, 0.00379108, -0.258618, 0.965972, 0.0, 0.239144, 0.245154, -0.939526, 0.0, 0.758731, -0.555871, 0.33961, 0.0, 0.295355, 0.309513, 0.903862, 0.0, 0.0531222, -0.91003, -0.411124, 0.0, 0.270452, 0.0229439, -0.96246, 0.0, 0.563634, 0.0324352, 0.825387, 0.0, 0.156326, 0.147392, 0.976646, 0.0, -0.0410141, 0.981824, 0.185309, 0.0, -0.385562, -0.576343, -0.720535, 0.0, 0.388281, 0.904441, 0.176702, 0.0, 0.945561, -0.192859, -0.262146, 0.0, 0.844504, 0.520193, 0.127325, 0.0, 0.0330893, 0.999121, -0.0257505, 0.0, -0.592616, -0.482475, -0.644999, 0.0, 0.539471, 0.631024, -0.557476, 0.0, 0.655851, -0.027319, -0.754396, 0.0, 0.274465, 0.887659, 0.369772, 0.0, -0.123419, 0.975177, -0.183842, 0.0, -0.223429, 0.708045, 0.66989, 0.0, -0.908654, 0.196302, 0.368528, 0.0, -0.95759, -0.00863708, 0.288005, 0.0, 0.960535, 0.030592, 0.276472, 0.0, -0.413146, 0.907537, 0.0754161, 0.0, -0.847992, 0.350849, -0.397259, 0.0, 0.614736, 0.395841, 0.68221, 0.0, -0.503504, -0.666128, -0.550234, 0.0, -0.268833, -0.738524, -0.618314, 0.0, 0.792737, -0.60001, -0.107502, 0.0, -0.637582, 0.508144, -0.579032, 0.0, 0.750105, 0.282165, -0.598101, 0.0, -0.351199, -0.392294, -0.850155, 0.0, 0.250126, -0.960993, -0.118025, 0.0, -0.732341, 0.680909, -0.0063274, 0.0, -0.760674, -0.141009, 0.633634, 0.0, 0.222823, -0.304012, 0.926243, 0.0, 0.209178, 0.505671, 0.836984, 0.0, 0.757914, -0.56629, -0.323857, 0.0, -0.782926, -0.339196, 0.52151, 0.0, -0.462952, 0.585565, 0.665424, 0.0, 0.61879, 0.194119, -0.761194, 0.0, 0.741388, -0.276743, 0.611357, 0.0, 0.707571, 0.702621, 0.0752872, 0.0, 0.156562, 0.819977, 0.550569, 0.0, -0.793606, 0.440216, 0.42, 0.0, 0.234547, 0.885309, -0.401517, 0.0, 0.132598, 0.80115, -0.58359, 0.0, -0.377899, -0.639179, 0.669808, 0.0, -0.865993, -0.396465, 0.304748, 0.0, -0.624815, -0.44283, 0.643046, 0.0, -0.485705, 0.825614, -0.287146, 0.0, -0.971788, 0.175535, 0.157529, 0.0, -0.456027, 0.392629, 0.798675, 0.0, -0.0104443, 0.521623, -0.853112, 0.0, -0.660575, -0.74519, 0.091282, 0.0, -0.0157698, -0.307475, -0.951425, 0.0, -0.603467, -0.250192, 0.757121, 0.0, 0.506876, 0.25006, 0.824952, 0.0, 0.255404, 0.966794, 0.00884498, 0.0, 0.466764, -0.874228, -0.133625, 0.0, 0.475077, -0.0682351, -0.877295, 0.0, -0.224967, -0.938972, -0.260233, 0.0, -0.377929, -0.814757, -0.439705, 0.0, -0.305847, 0.542333, -0.782517, 0.0, 0.26658, -0.902905, -0.337191, 0.0, 0.0275773, 0.322158, -0.946284, 0.0, 0.0185422, 0.716349, 0.697496, 0.0, -0.20483, 0.978416, 0.0273371, 0.0, -0.898276, 0.373969, 0.230752, 0.0, -0.00909378, 0.546594, 0.837349, 0.0, 0.6602, -0.751089, 0.000959236, 0.0, 0.855301, -0.303056, 0.420259, 0.0, 0.797138, 0.0623013, -0.600574, 0.0, 0.48947, -0.866813, 0.0951509, 0.0, 0.251142, 0.674531, 0.694216, 0.0, -0.578422, -0.737373, -0.348867, 0.0, -0.254689, -0.514807, 0.818601, 0.0, 0.374972, 0.761612, 0.528529, 0.0, 0.640303, -0.734271, -0.225517, 0.0, -0.638076, 0.285527, 0.715075, 0.0, 0.772956, -0.15984, -0.613995, 0.0, 0.798217, -0.590628, 0.118356, 0.0, -0.986276, -0.0578337, -0.154644, 0.0, -0.312988, -0.94549, 0.0899272, 0.0, -0.497338, 0.178325, 0.849032, 0.0, -0.101136, -0.981014, 0.165477, 0.0, -0.521688, 0.0553434, -0.851339, 0.0, -0.786182, -0.583814, 0.202678, 0.0, -0.565191, 0.821858, -0.0714658, 0.0, 0.437895, 0.152598, -0.885981, 0.0, -0.92394, 0.353436, -0.14635, 0.0, 0.212189, -0.815162, -0.538969, 0.0, -0.859262, 0.143405, -0.491024, 0.0, 0.991353, 0.112814, 0.0670273, 0.0, 0.0337884, -0.979891, -0.196654, 0.0];

}


class Noise {
	static var X_NOISE_GEN = 1619;
	static var Y_NOISE_GEN = 31337;
	static var Z_NOISE_GEN = 6971;
	static var SEED_NOISE_GEN = 1013;
	static var SHIFT_NOISE_GEN = 8;

	/**
	 * Generates a gradient-coherent-noise value from the coordinates of a
	 * three-dimensional input value.
	 *
	 * @param x The @a x coordinate of the input value.
	 * @param y The @a y coordinate of the input value.
	 * @param z The @a z coordinate of the input value.
	 * @param seed The random number seed.
	 * @param noiseQuality The quality of the coherent-noise.
	 * @return The generated gradient-coherent-noise value.
	 *
	 *         The return value ranges from -1.0 to +1.0.
	 *
	 *         For an explanation of the difference between <i>gradient</i>
	 *         noise and <i>value</i> noise, see the comments for the
	 *         GradientNoise3D() function.
	 */
	static fun GradientCoherentNoise3D(x: Number, y: Number, z: Number, seed: Number, quality: NoiseQuality) {

		// Create a unit-length cube aligned along an integer boundary.  This cube
		// surrounds the input point.

        if(x > 0.0)
            x0 = x;
        else
            x0 = x - 1;
        x1 = x0 + 1;

		if(y > 0.0)
            y0 = y;
        else
            y0 = y - 1;
        y1 = y0 + 1;

        if(z > 0.0)
            z0 = z;
        else
            z0 = z - 1;
        z1 = z0 + 1;


		// Map the difference between the coordinates of the input value and the
		// coordinates of the cube's outer-lower-left vertex onto an S-curve.
		xs = 0;
        ys = 0;
        zs = 0;
		if (quality == NoiseQuality.FAST) {
			xs = (x - x0);
			ys = (y - y0);
			zs = (z - z0);

		} else if (quality == NoiseQuality.STANDARD) {
			xs = NoiseUtils.SCurve3(x - x0);
			ys = NoiseUtils.SCurve3(y - y0);
			zs = NoiseUtils.SCurve3(z - z0);
		} else {

			xs = NoiseUtils.SCurve5(x - x0);
			ys = NoiseUtils.SCurve5(y - y0);
			zs = NoiseUtils.SCurve5(z - z0);
		}

		// Now calculate the noise values at each vertex of the cube.  To generate
		// the coherent-noise value at the input point, interpolate these eight
		// noise values using the S-curve value as the interpolant (trilinear
		// interpolation.)
		n0 = Noise.GradientNoise3D(x, y, z, x0, y0, z0, seed);
		n1 = Noise.GradientNoise3D(x, y, z, x1, y0, z0, seed);
		ix0 = Math.lerp(n0, n1, xs);

		n0 = Noise.GradientNoise3D(x, y, z, x0, y1, z0, seed);
		n1 = Noise.GradientNoise3D(x, y, z, x1, y1, z0, seed);
		ix1 = Math.lerp(n0, n1, xs);
		iy0 = Math.lerp(ix0, ix1, ys);
		n0 = Noise.GradientNoise3D(x, y, z, x0, y0, z1, seed);
		n1 = Noise.GradientNoise3D(x, y, z, x1, y0, z1, seed);
		ix0 = Math.lerp(n0, n1, xs);
		n0 = Noise.GradientNoise3D(x, y, z, x0, y1, z1, seed);
		n1 = Noise.GradientNoise3D(x, y, z, x1, y1, z1, seed);
		ix1 = Math.lerp(n0, n1, xs);
		iy1 = Math.lerp(ix0, ix1, ys);
		return Math.lerp(iy0, iy1, zs);

	}

	/**
	 * Generates a gradient-noise value from the coordinates of a
	 * three-dimensional input value and the integer coordinates of a nearby
	 * three-dimensional value.
	 *
	 * @param fx The floating-point @a x coordinate of the input value.
	 * @param fy The floating-point @a y coordinate of the input value.
	 * @param fz The floating-point @a z coordinate of the input value.
	 * @param ix The integer @a x coordinate of a nearby value.
	 * @param iy The integer @a y coordinate of a nearby value.
	 * @param iz The integer @a z coordinate of a nearby value.
	 * @param seed The random number seed.
	 * @return The generated gradient-noise value.
	 *
	 *         The difference between fx and ix must be less than or equal to
	 *         one. The difference between @a fy and @a iy must be less than or
	 *         equal to one. The difference between @a fz and @a iz must be less
	 *         than or equal to one.
	 *
	 *         A <i>gradient</i>-noise function generates better-quality noise
	 *         than a <i>value</i>-noise function. Most noise modules use
	 *         gradient noise for this reason, although it takes much longer to
	 *         calculate.
	 *
	 *         The return value ranges from -1.0 to +1.0.
	 *
	 *         This function generates a gradient-noise value by performing the
	 *         following steps: - It first calculates a random normalized vector
	 *         based on the nearby integer value passed to this function. - It
	 *         then calculates a new value by adding this vector to the nearby
	 *         integer value passed to this function. - It then calculates the
	 *         dot product of the above-generated value and the floating-point
	 *         input value passed to this function.
	 *
	 *         A noise function differs from a random-number generator because
	 *         it always returns the same output value if the same input value
	 *         is passed to it.
	 */
	static fun GradientNoise3D(fx: Number, fy: Number, fz: Number, ix: Number, iy: Number, iz: Number, int: Number) {
		// Randomly generate a gradient vector given the integer coordinates of the
		// input value.  This implementation generates a random number and uses it
		// as an index into a normalized-vector lookup table.
		vectorIndex = (Noise.X_NOISE_GEN * ix + Noise.Y_NOISE_GEN * iy + Noise.Z_NOISE_GEN * iz + Noise.SEED_NOISE_GEN * seed);
		vectorIndex = vectorIndex^(vectorIndex >> Noise.SHIFT_NOISE_GEN);
		vectorIndex = vectorIndex & 0xff;

		xvGradient = NoiseUtils.RandomVectors[(vectorIndex << 2)];
		yvGradient = NoiseUtils.RandomVectors[(vectorIndex << 2) + 1];
		zvGradient = NoiseUtils.RandomVectors[(vectorIndex << 2) + 2];

		// Set up us another vector equal to the distance between the two vectors
		// passed to this function.
		xvPoint = (fx - ix);
		yvPoint = (fy - iy);
		zvPoint = (fz - iz);

		// Now compute the dot product of the gradient vector with the distance
		// vector.  The resulting value is gradient noise.  Apply a scaling value
		// so that this noise value ranges from -1.0 to 1.0.
		return ((xvGradient * xvPoint) + (yvGradient * yvPoint) + (zvGradient * zvPoint)) * 2.12;
	}

	/**
	 * Generates an integer-noise value from the coordinates of a
	 * three-dimensional input value.
	 *
	 * @param x The integer @a x coordinate of the input value.
	 * @param y The integer @a y coordinate of the input value.
	 * @param z The integer @a z coordinate of the input value.
	 * @param seed A random number seed.
	 * @return The generated integer-noise value.
	 *
	 *         The return value ranges from 0 to 2147483647.
	 *
	 *         A noise function differs from a random-number generator because
	 *         it always returns the same output value if the same input value
	 *         is passed to it.
	 */
	static fun IntValueNoise3D(x: Number, y: Number, z: Number, seed: Number) {
		// All constants are primes and must remain prime in order for this noise
		// function to work correctly.
		n = (Noise.X_NOISE_GEN * x + Noise.Y_NOISE_GEN * y + Noise.Z_NOISE_GEN * z + Noise.SEED_NOISE_GEN * seed) & 0x7fffffff;
		n = (n >> 13) ^ n;
		return (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;

	}

	/**
	 * Generates a value-coherent-noise value from the coordinates of a
	 * three-dimensional input value.
	 *
	 * @param x The @a x coordinate of the input value.
	 * @param y The @a y coordinate of the input value.
	 * @param z The @a z coordinate of the input value.
	 * @param seed The random number seed.
	 * @param noiseQuality The quality of the coherent-noise.
	 * @return The generated value-coherent-noise value.
	 *
	 *         The return value ranges from -1.0 to +1.0.
	 *
	 *         For an explanation of the difference between <i>gradient</i>
	 *         noise and <i>value</i> noise, see the comments for the
	 *         GradientNoise3D() function.
	 */
	static fun ValueCoherentNoise3D(x: Number, y: Number, z: Number, seed: Number, quality: NoiseQuality) {
		// Create a unit-length cube aligned along an integer boundary.  This cube
		// surrounds the input point.
        if(x > 0.0)
            x0 = x;
        else
            x0 = x - 1;
        x1 = x0 + 1;

		if(y > 0.0)
            y0 = y;
        else
            y0 = y - 1;
        y1 = y0 + 1;

        if(z > 0.0)
            z0 = z;
        else
            z0 = z - 1;
        z1 = z0 + 1;

		// Map the difference between the coordinates of the input value and the
		// coordinates of the cube's outer-lower-left vertex onto an S-curve.
		xs = 0;
        ys = 0;
        zs = 0;
		if (quality == NoiseQuality.FAST) {
			xs = (x - x0);
			ys = (y - y0);
			zs = (z - z0);

		} else if (quality == NoiseQuality.STANDARD) {
			xs = NoiseUtils.SCurve3(x - x0);
			ys = NoiseUtils.SCurve3(y - y0);
			zs = NoiseUtils.SCurve3(z - z0);
		} else {

			xs = NoiseUtils.SCurve5(x - x0);
			ys = NoiseUtils.SCurve5(y - y0);
			zs = NoiseUtils.SCurve5(z - z0);
		}

		// Now calculate the noise values at each vertex of the cube.  To generate
		// the coherent-noise value at the input point, interpolate these eight
		// noise values using the S-curve value as the interpolant (trilinear
		// interpolation.)
		n0 = Noise.ValueNoise3D(x0, y0, z0, seed);
		n1 = Noise.ValueNoise3D(x1, y0, z0, seed);
		ix0 = Math.lerp(n0, n1, xs);
		n0 = Noise.ValueNoise3D(x0, y1, z0, seed);
		n1 = Noise.ValueNoise3D(x1, y1, z0, seed);
		ix1 = Math.lerp(n0, n1, xs);
		iy0 = Math.lerp(ix0, ix1, ys);
		n0 = Noise.ValueNoise3D(x0, y0, z1, seed);
		n1 = Noise.ValueNoise3D(x1, y0, z1, seed);
		ix0 = Math.lerp(n0, n1, xs);
		n0 = Noise.ValueNoise3D(x0, y1, z1, seed);
		n1 = Noise.ValueNoise3D(x1, y1, z1, seed);
		ix1 = Math.lerp(n0, n1, xs);
		iy1 = Math.lerp(ix0, ix1, ys);
		return Math.lerp(iy0, iy1, zs);

	}

	/**
	 * Generates a value-noise value from the coordinates of a three-dimensional
	 * input value.
	 *
	 * @param x The @a x coordinate of the input value.
	 * @param y The @a y coordinate of the input value.
	 * @param z The @a z coordinate of the input value.
	 * @param seed A random number seed.
	 * @return The generated value-noise value.
	 *
	 *         The return value ranges from -1.0 to +1.0.
	 *
	 *         A noise function differs from a random-number generator because
	 *         it always returns the same output value if the same input value
	 *         is passed to it.
	 */
	static fun ValueNoise3D(x: Number, y: Number, z: Number, seed: Number) {
		return 1.0 - (Noise.IntValueNoise3D(x, y, z, seed) / 1073741824.0);
	}

}

class Voronoi{

	/// Default displacement to apply to each cell for the
	/// noise::module::Voronoi noise module.
	static var DEFAULT_VORONOI_DISPLACEMENT = 1.0;

	/// Default frequency of the seed points for the noise::module::Voronoi
	/// noise module.
	static var DEFAULT_VORONOI_FREQUENCY = 1.0;

	/// Default seed of the noise function for the noise::module::Voronoi
	/// noise module.
	static var DEFAULT_VORONOI_SEED = 0;

	/// Scale of the random displacement to apply to each Voronoi cell.
	var displacement = Voronoi.DEFAULT_VORONOI_DISPLACEMENT;

	/// Determines if the distance from the nearest seed point is applied to
	/// the output value.
	var enableDistance = false;

	/// Frequency of the seed points.
	var frequency = Voronoi.DEFAULT_VORONOI_FREQUENCY;

	/// Seed value used by the coherent-noise function to determine the
	/// positions of the seed points.
	var seed = Voronoi.DEFAULT_VORONOI_SEED;

	Voronoi() {
	}

	fun getDisplacement() {
		return this.displacement;
	}

	fun setDisplacement(displacement: Number) {
		this.displacement = displacement;
	}

	fun isEnableDistance() {
		return this.enableDistance;
	}

	fun setEnableDistance(enableDistance: Boolean) {
		this.enableDistance = enableDistance;
	}

	fun getFrequency() {
		return this.frequency;
	}

	fun setFrequency(frequency) {
		this.frequency = frequency;
	}

	fun getSeed() {
		return this.seed;
	}

	fun setSeed(seed: Number) {
		this.seed = seed;
	}


    fun getValue(x: Number, y: Number, z: Number) {
        x1 = x;
        y1 = y;
        z1 = z;
        // This method could be more efficient by caching the seed values.  Fix
        // later.

        x1 = x1 * this.frequency;
        y1 = y1 * this.frequency;
        z1 = z1 * this.frequency;

        if(x1 > 0.0)
            x1 = x1;
        else
            x1= x1 - 1;

        if(y1 > 0.0)
            y1 = y1;
        else
            y1= y1 - 1;

        if(z1 > 0.0)
            z1 = z1;
        else
            z1= z1 - 1;


        minDist = 2147483647.0;
        xCandidate = 0;
        yCandidate = 0;
        zCandidate = 0;

        // Inside each unit cube, there is a seed point at a random position.  Go
        // through each of the nearby cubes until we find a cube with a seed point
        // that is closest to the specified position.
        for (zCur = zInt - 2; zCur <= zInt + 2; zCur++) {
            for (yCur = yInt - 2; yCur <= yInt + 2; yCur++) {
                for (xCur = xInt - 2; xCur <= xInt + 2; xCur++) {

                    // Calculate the position and distance to the seed point inside of
                    // this unit cube.
                    xPos = xCur + Noise.ValueNoise3D(xCur, yCur, zCur, this.seed);
                    yPos = yCur + Noise.ValueNoise3D(xCur, yCur, zCur, this.seed + 1);
                    zPos = zCur + Noise.ValueNoise3D(xCur, yCur, zCur, this.seed + 2);
                    xDist = xPos - x1;
                    yDist = yPos - y1;
                    zDist = zPos - z1;
                    dist = xDist * xDist + yDist * yDist + zDist * zDist;

                    if (dist < minDist) {
                        // This seed point is closer to any others found so far, so record
                        // this seed point.
                        minDist = dist;
                        xCandidate = xPos;
                        yCandidate = yPos;
                        zCandidate = zPos;
                    }
                }
            }
        }

        value = 0;
        if (this.enableDistance) {
            // Determine the distance to the nearest seed point.
            xDist = xCandidate - x1;
            yDist = yCandidate - y1;
            zDist = zCandidate - z1;
            value = (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist)) * NoiseUtils.SQRT_3 - 1.0;
        } else {
            value = 0.0;
        }

        // Return the calculated distance with the displacement value applied.
        return value + (displacement * Noise.ValueNoise3D( (Math.floor(xCandidate)),  (Math.floor(yCandidate)),  (Math.floor(zCandidate)), this.seed));

    }

}

class RidgedMulti {

	/// Default frequency for the noise::module::RidgedMulti noise module.
	static var DEFAULT_RIDGED_FREQUENCY = 1.0;

	/// Default lacunarity for the noise::module::RidgedMulti noise module.
	static var DEFAULT_RIDGED_LACUNARITY = 2.0;

	/// Default number of octaves for the noise::module::RidgedMulti noise
	/// module.
	static var DEFAULT_RIDGED_OCTAVE_COUNT = 6;

	/// Default noise quality for the noise::module::RidgedMulti noise
	/// module.
	static var DEFAULT_RIDGED_QUALITY = NoiseQuality.STANDARD;

	/// Default noise seed for the noise::module::RidgedMulti noise module.
	static var DEFAULT_RIDGED_SEED = 0;

	/// Maximum number of octaves for the noise::module::RidgedMulti noise
	/// module.
	static var RIDGED_MAX_OCTAVE = 30;

	var frequency = RidgedMulti.DEFAULT_RIDGED_FREQUENCY;

	/// Frequency multiplier between successive octaves.
	var lacunarity = RidgedMulti.DEFAULT_RIDGED_LACUNARITY;

	/// Quality of the ridged-multifractal noise.
	var noiseQuality = RidgedMulti.DEFAULT_RIDGED_QUALITY;

	/// Total number of octaves that generate the ridged-multifractal
	/// noise.
	var octaveCount = RidgedMulti.DEFAULT_RIDGED_OCTAVE_COUNT;

	/// Contains the spectral weights for each octave.
	var SpectralWeights;

	/// Seed value used by the ridged-multfractal-noise function.
	var seed = DEFAULT_RIDGED_SEED;

	fun RidgedMulti() {
		CalcSpectralWeights();
	}

	fun getFrequency() {
		return frequency;
	}

	fun setFrequency(frequency: Number) {
		this.frequency = frequency;
	}

	fun getLacunarity() {
		return lacunarity;
	}

	fun setLacunarity(lacunarity: Number) {
		this.lacunarity = lacunarity;
	}

	fun getNoiseQuality() {
		return noiseQuality;
	}

	fun setNoiseQuality(noiseQuality: NoiseQuality) {
		this.noiseQuality = noiseQuality;
	}

	fun getOctaveCount() {
		return octaveCount;
	}

	fun setOctaveCount(octaveCount: Number) {
		this.octaveCount = Math.min(octaveCount, RidgedMulti.RIDGED_MAX_OCTAVE);
	}

	fun getSeed() {
		return seed;
	}

	fun setSeed(seed: Number) {
		this.seed = seed;
	}

	fun CalcSpectralWeights() {
		// This exponent parameter should be user-defined; it may be exposed in a
		// future version of libnoise.
		h = 1.0;

		frequency = 1.0;
		this.spectralWeights = [];
		for (i = 0; i < RidgedMulti.RIDGED_MAX_OCTAVE; i++) {
			// Compute weight for each frequency.
			this.spectralWeights[i] = Math.pow(frequency, -h);
			frequency = frequency * this.lacunarity;
		}
	}

    fun getValue(x: Number, y: Number, z: Number) {
        x1 = x * this.frequency;
        y1 = y * this.requency;
        z1 = z * this.frequency;

        signal;
        value = 0.0;
        weight = 1.0;

        // These parameters should be user-defined; they may be exposed in a
        // future version of libnoise.
        offset = 1.0;
        gain = 2.0;

        for (curOctave = 0; curOctave < this.octaveCount; curOctave++) {

            // Make sure that these floating-point values have the same range as a 32-
            // bit integer so that we can pass them to the coherent-noise functions.
            nx = x1;
            ny = y1;
            nz = z1;

            // Get the coherent-noise value.
            seed = (this.seed + curOctave) & 0x7fffffff;
            signal = Noise.GradientCoherentNoise3D(nx, ny, nz, seed, this.noiseQuality);

            // Make the ridges.
            signal = Math.abs(signal);
            signal = offset - signal;

            // Square the signal to increase the sharpness of the ridges.
            //noinspection UnusedAssignment
            signal = signal^2;

            // The weighting from the previous octave is applied to the signal.
            // Larger values have higher weights, producing sharp points along the
            // ridges.
            signal = signal * weight;

            // Weight successive contributions by the previous signal.
            weight = signal * gain;
            if (weight > 1.0) {
                weight = 1.0;
            }
            if (weight < 0.0) {
                weight = 0.0;
            }

            // Add the signal to the output value.
            value = value + (signal * this.spectralWeights[curOctave]);

            // Go to the next octave.
            x1 = x1 * this.lacunarity;
            y1 = y1 * this.lacunarity;
            z1 = z1 * this.lacunarity;
        }

        return (value * 1.25) - 1.0;

    }

}

class Perlin {

	/// Default frequency for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_FREQUENCY = 1.0;

	/// Default lacunarity for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_LACUNARITY = 2.0;

	/// Default number of octaves for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_OCTAVE_COUNT = 6;

	/// Default persistence value for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_PERSISTENCE = 0.5;

	/// Default noise quality for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_QUALITY = NoiseQuality.STANDARD;

	/// Default noise seed for the noise::module::Perlin noise module.
	static var DEFAULT_PERLIN_SEED = 0;

	/// Maximum number of octaves for the noise::module::Perlin noise module.
	static var PERLIN_MAX_OCTAVE = 30;

	/// Frequency of the first octave.
	var frequency = Perlin.DEFAULT_PERLIN_FREQUENCY;

	/// Frequency multiplier between successive octaves.
	var lacunarity = Perlin.DEFAULT_PERLIN_LACUNARITY;

	/// Quality of the Perlin noise.
	var noiseQuality = Perlin.DEFAULT_PERLIN_QUALITY;

	/// Total number of octaves that generate the Perlin noise.
	var octaveCount = Perlin.DEFAULT_PERLIN_OCTAVE_COUNT;

	/// Persistence of the Perlin noise.
	var persistence = Perlin.DEFAULT_PERLIN_PERSISTENCE;

	/// Seed value used by the Perlin-noise function.
	var seed = Perlin.DEFAULT_PERLIN_SEED;

    Perlin() {

	}

	fun getFrequency() {
		return this.frequency;
	}

	fun setFrequency(frequency: Number) {
		this.frequency = frequency;
	}

	fun getLacunarity() {
		return this.lacunarity;
	}

	fun setLacunarity(lacunarity: Number) {
		this.lacunarity = lacunarity;
	}

	fun getNoiseQuality() {
		return this.noiseQuality;
	}

	fun setNoiseQuality(noiseQuality: NoiseQuality) {
		this.noiseQuality = noiseQuality;
	}

	fun getOctaveCount() {
		return this.octaveCount;
	}

	fun setOctaveCount(octaveCount: Number) {
		if (octaveCount < 1 || octaveCount > PERLIN_MAX_OCTAVE) {
			throw new IllegalArgumentException("octaveCount must be between 1 and MAX OCTAVE: " + PERLIN_MAX_OCTAVE);
		}

		this.octaveCount = octaveCount;
	}

	fun getPersistence() {
		return persistence;
	}

	fun setPersistence(persistence: Number) {
		this.persistence = persistence;
	}

	fun getSeed() {
        return seed;
	}

	fun setSeed(seed: Number) {
		this.seed = seed;
	}

    fun getValue(x, y, z) {

        value = 0.0;
        signal = 0;
        curPersistence = 1.0;

        x1 = x * this.frequency;
        y1 = y * this.frequency;
        z1 = z * this.frequency;

        for (curOctave = 0; curOctave < octaveCount; curOctave++) {
            // Get the coherent-noise value from the input value and add it to the
            // final result.
            seed = (this.seed + curOctave);
            signal = Noise.GradientCoherentNoise3D(x1, y1, z1, this.seed, this.noiseQuality);
            value = value + signal * curPersistence;

            // Prepare the next octave.
            x1 = x1 * lacunarity;
            y1 = y1 * lacunarity;
            z1 = z1 * lacunarity;
            curPersistence = curPersistence * persistence;
        }
        return value;
    }
}


new PerlinNoise();