{
  "Boolean Class": {
    "prefix": "Boolean",
    "body": "Boolean",
    "description": "The Boolean class.\nThis is the boolean type, representing either true or false.\nThis class cannot be instantiated, or extended\n"
  },
  "Collection Class": {
    "prefix": "Collection",
    "body": "Collection",
    "description": "The Collection class.\nThis class is used to represent a collection of objects,\nthis class is used internally as the parent of maps, lists, and sets.\nThis cannot be instantiated directly.\nAll collections inherit Iterable, and thus can be iterated over\n"
  },
  "Method <Collection>.isEmpty()": {
    "prefix": ".isEmpty()",
    "body": ".isEmpty()",
    "description": "<Collection>.isEmpty()\nThis allows you to check if the collection is empty\n"
  },
  "Method <Collection>.size()": {
    "prefix": ".size()",
    "body": ".size()",
    "description": "<Collection>.size()\nThis allows you to get the size of the collection\n"
  },
  "Enum Class": {
    "prefix": "Enum",
    "body": "Enum",
    "description": "The Enum class.\nThis class is the super class of all enums in Arucas.\nEnums cannot be instantiated or extended\n"
  },
  "Method <Enum>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Enum>.getName()\nThis allows you to get the name of an enum value\n"
  },
  "Method <Enum>.ordinal()": {
    "prefix": ".ordinal()",
    "body": ".ordinal()",
    "description": "<Enum>.ordinal()\nThis allows you to get the ordinal of the enum value\n"
  },
  "Error Class": {
    "prefix": "Error",
    "body": "Error",
    "description": "The Error class.\nThis class is used for errors, and this is the only type that can be thrown.\nYou are able to extend this class to create your own error types\n"
  },
  "Method <Error>.getDetails()": {
    "prefix": ".getDetails()",
    "body": ".getDetails()",
    "description": "<Error>.getDetails()\nThis returns the raw message of the error\n"
  },
  "Method <Error>.getStackTraceString()": {
    "prefix": ".getStackTraceString()",
    "body": ".getStackTraceString()",
    "description": "<Error>.getStackTraceString()\nThis prints the stack trace of this error\n"
  },
  "Method <Error>.getValue()": {
    "prefix": ".getValue()",
    "body": ".getValue()",
    "description": "<Error>.getValue()\nThis returns the value that is related to the error\n"
  },
  "File Class": {
    "prefix": "File",
    "body": "File",
    "description": "The File class.\nThis class allows you to read and write files\n"
  },
  "Static Method File.getDirectory()": {
    "prefix": "File.getDirectory()",
    "body": "File.getDirectory()",
    "description": "File.getDirectory()\nThis returns the file of the working directory\n"
  },
  "Method <File>.createDirectory()": {
    "prefix": ".createDirectory()",
    "body": ".createDirectory()",
    "description": "<File>.createDirectory()\nThis creates all parent directories of the file if they don't already exist\n"
  },
  "Method <File>.delete()": {
    "prefix": ".delete()",
    "body": ".delete()",
    "description": "<File>.delete()\nThis deletes the file\n"
  },
  "Method <File>.exists()": {
    "prefix": ".exists()",
    "body": ".exists()",
    "description": "<File>.exists()\nThis returns if the file exists\n"
  },
  "Method <File>.getAbsolutePath()": {
    "prefix": ".getAbsolutePath()",
    "body": ".getAbsolutePath()",
    "description": "<File>.getAbsolutePath()\nThis returns the absolute path of the file\n"
  },
  "Method <File>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<File>.getName()\nThis returns the name of the file\n"
  },
  "Method <File>.getPath()": {
    "prefix": ".getPath()",
    "body": ".getPath()",
    "description": "<File>.getPath()\nThis returns the path of the file\n"
  },
  "Method <File>.getSubFiles()": {
    "prefix": ".getSubFiles()",
    "body": ".getSubFiles()",
    "description": "<File>.getSubFiles()\nThis returns a list of all the sub files in the directory\n"
  },
  "Method <File>.open()": {
    "prefix": ".open()",
    "body": ".open()",
    "description": "<File>.open()\nThis opens the file (as in opens it on your os)\n"
  },
  "Method <File>.read()": {
    "prefix": ".read()",
    "body": ".read()",
    "description": "<File>.read()\nThis reads the file and returns the contents as a string\n"
  },
  "Method <File>.resolve(filePath)": {
    "prefix": ".resolve($filePath)",
    "body": ".resolve($filePath)",
    "description": "<File>.resolve(filePath)\nThis gets a resolves file object from the current one\n- Parameter - String (`filePath`): the relative file path\n"
  },
  "Method <File>.write(string)": {
    "prefix": ".write($string)",
    "body": ".write($string)",
    "description": "<File>.write(string)\nThis writes a string to a file\n- Parameter - String (`string`): the string to write to the file\n"
  },
  "Function Class": {
    "prefix": "Function",
    "body": "Function",
    "description": "The Function class.\nThis class is used for functions, and this is the only type that can be called.\nYou are able to extend this class and implement an 'invoke' method to create\nyour own function types, this class cannot be instantiated directly\n"
  },
  "Future Class": {
    "prefix": "Future",
    "body": "Future",
    "description": "The Future class.\nThis class is used to represent values that are in the future.\nMore precisely values that are being evaluated on another thread,\nthis allows you to access those values once they've been processed\n"
  },
  "Static Method Future.completed(value)": {
    "prefix": "Future.completed(value)",
    "body": "Future.completed($value)",
    "description": "Future.completed(value)\nThis returns a future that with a complete value\n- Parameter - Object (`value`): The value to complete the future with\n"
  },
  "Method <Future>.await()": {
    "prefix": ".await()",
    "body": ".await()",
    "description": "<Future>.await()\nThis blocks the current thread until the future has\nbeen completed and then returns the value of the future\n"
  },
  "Method <Future>.isComplete()": {
    "prefix": ".isComplete()",
    "body": ".isComplete()",
    "description": "<Future>.isComplete()\nThis returns whether the future has been completed\n"
  },
  "Iterable Class": {
    "prefix": "Iterable",
    "body": "Iterable",
    "description": "The Iterable class.\nThis class represents an object that can be iterated over.\nThis class is used internally to denote whether an object can be\niterated over inside a foreach loop\n"
  },
  "Method <Iterable>.iterator()": {
    "prefix": ".iterator()",
    "body": ".iterator()",
    "description": "<Iterable>.iterator()\nThis gets the generated iterator\n"
  },
  "Iterator Class": {
    "prefix": "Iterator",
    "body": "Iterator",
    "description": "The Iterator class.\nThis class represents an object that iterates.\nThis is what is used internally to iterate in a\nforeach loop and you can create your own iterators\nto use be able to use them inside a foreach\n"
  },
  "Method <Iterator>.hasNext()": {
    "prefix": ".hasNext()",
    "body": ".hasNext()",
    "description": "<Iterator>.hasNext()\nChecks whether the iterator has a next item to iterate\n"
  },
  "Method <Iterator>.next()": {
    "prefix": ".next()",
    "body": ".next()",
    "description": "<Iterator>.next()\nGets the next item in the iterator, may throw if there is no next item\n"
  },
  "Java Class": {
    "prefix": "Java",
    "body": "Java",
    "description": "The Java class from util.Internal.\nThis class wraps Java values allowing for interactions between Java and Arucas.\nThis class cannot be instantiated or extended but you can create Java values by\nusing the static method 'Java.valueOf()' to convert Arucas to Java\n"
  },
  "Static Method Java.arrayOf(values...)": {
    "prefix": "Java.arrayOf(values...)",
    "body": "Java.arrayOf($values...)",
    "description": "Java.arrayOf(values...)\nCreates a Java Object array with a given values, this will be the size of the array,\nthis cannot be used to create primitive arrays\n- Parameter - Object (`values...`): the values to add to the array\n"
  },
  "Static Method Java.booleanArray(size)": {
    "prefix": "Java.booleanArray(size)",
    "body": "Java.booleanArray($size)",
    "description": "Java.booleanArray(size)\nCreates a Java boolean array with a given size, the array is filled with false\nby default and can be filled with only booleans\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.booleanOf(bool)": {
    "prefix": "Java.booleanOf(bool)",
    "body": "Java.booleanOf($bool)",
    "description": "Java.booleanOf(bool)\nCreates a Java value boolean, to be used in Java\n- Parameter - Boolean (`bool`): the boolean to convert to a Java boolean\n"
  },
  "Static Method Java.byteArray(size)": {
    "prefix": "Java.byteArray(size)",
    "body": "Java.byteArray($size)",
    "description": "Java.byteArray(size)\nCreates a Java byte array with a given size, the array is filled with 0's\nby default and can be filled with only bytes\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.byteOf(num)": {
    "prefix": "Java.byteOf(num)",
    "body": "Java.byteOf($num)",
    "description": "Java.byteOf(num)\nCreates a Java value byte, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java byte\n"
  },
  "Static Method Java.callStaticMethod(className, methodName, parameters...)": {
    "prefix": "Java.callStaticMethod(className, methodName, parameters...)",
    "body": "Java.callStaticMethod($className, $methodName, $parameters...)",
    "description": "Java.callStaticMethod(className, methodName, parameters...)\nCalls a static method of a Java class.\nThis should be avoided and instead use 'classOf' to get the\ninstance of the class then call the static method on that\n- Parameter - String (`className`): the name of the class\n- Parameter - String (`methodName`): the name of the method\n- Parameter - Object (`parameters...`): any parameters to call the method with\n"
  },
  "Static Method Java.charArray(size)": {
    "prefix": "Java.charArray(size)",
    "body": "Java.charArray($size)",
    "description": "Java.charArray(size)\nCreates a Java char array with a given size, the array is filled with null characters's\nby default and can be filled with only chars\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.charOf(char)": {
    "prefix": "Java.charOf(char)",
    "body": "Java.charOf($char)",
    "description": "Java.charOf(char)\nCreates a Java value char, to be used in Java\n- Parameter - String (`char`): the char to convert to a Java char\n"
  },
  "Static Method Java.classFromName(className)": {
    "prefix": "Java.classFromName(className)",
    "body": "Java.classFromName($className)",
    "description": "Java.classFromName(className)\nGets a Java class from the name of the class\n- Parameter - String (`className`): the name of the class you want to get\n"
  },
  "Static Method Java.classOf(className)": {
    "prefix": "Java.classOf(className)",
    "body": "Java.classOf($className)",
    "description": "Java.classOf(className)\nGets a Java class from the name of the class\n- Parameter - String (`className`): the name of the class you want to get\n"
  },
  "Static Method Java.constructClass(className, parameters...)": {
    "prefix": "Java.constructClass(className, parameters...)",
    "body": "Java.constructClass($className, $parameters...)",
    "description": "Java.constructClass(className, parameters...)\nThis constructs a Java class with specified class name and parameters.\nThis should be avoided and instead use 'classOf' to get the class\ninstance then call the constructor on that instance\n- Parameter - String (`className`): the name of the class\n- Parameter - Object (`parameters...`): any parameters to pass to the constructor\n"
  },
  "Static Method Java.consumerOf(function)": {
    "prefix": "Java.consumerOf(function)",
    "body": "Java.consumerOf($function)",
    "description": "Java.consumerOf(function)\nCreates a Java Consumer object from a given function, it must have one\nparameter and any return values will be ignored\n- Parameter - Function (`function`): the function to be executed\n"
  },
  "Static Method Java.doubleArray(size)": {
    "prefix": "Java.doubleArray(size)",
    "body": "Java.doubleArray($size)",
    "description": "Java.doubleArray(size)\nCreates a Java double array with a given size, the array is filled with 0's\nby default and can be filled with only doubles\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.doubleOf(num)": {
    "prefix": "Java.doubleOf(num)",
    "body": "Java.doubleOf($num)",
    "description": "Java.doubleOf(num)\nCreates a Java value double, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java double\n"
  },
  "Static Method Java.floatArray(size)": {
    "prefix": "Java.floatArray(size)",
    "body": "Java.floatArray($size)",
    "description": "Java.floatArray(size)\nCreates a Java float array with a given size, the array is filled with 0's\nby default and can be filled with only floats\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.floatOf(num)": {
    "prefix": "Java.floatOf(num)",
    "body": "Java.floatOf($num)",
    "description": "Java.floatOf(num)\nCreates a Java value float, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java float\n"
  },
  "Static Method Java.functionOf(function)": {
    "prefix": "Java.functionOf(function)",
    "body": "Java.functionOf($function)",
    "description": "Java.functionOf(function)\nCreates a Java Function object from a given function\n- Parameter - Function (`function`): the function to be executed, this must have one parameter and must return a value\n"
  },
  "Static Method Java.getStaticField(className, fieldName)": {
    "prefix": "Java.getStaticField(className, fieldName)",
    "body": "Java.getStaticField($className, $fieldName)",
    "description": "Java.getStaticField(className, fieldName)\nGets a static field Java value from a Java class\n- Parameter - String (`className`): the name of the class\n- Parameter - String (`fieldName`): the name of the field\n"
  },
  "Static Method Java.getStaticMethodDelegate(className, methodName, parameters)": {
    "prefix": "Java.getStaticMethodDelegate(className, methodName, parameters)",
    "body": "Java.getStaticMethodDelegate($className, $methodName, $parameters)",
    "description": "Java.getStaticMethodDelegate(className, methodName, parameters)\nGets a static method delegate from a Java class, this should\nbe avoided and instance use 'classOf' to get the class instance\nand then call the method on that class instance. The parameter count\nparameter is no longer used internally but remains for backwards compatibility\n- Parameter - String (`className`): the name of the class\n- Parameter - String (`methodName`): the name of the method\n- Parameter - Number (`parameters`): the number of parameters\n"
  },
  "Static Method Java.intArray(size)": {
    "prefix": "Java.intArray(size)",
    "body": "Java.intArray($size)",
    "description": "Java.intArray(size)\nCreates a Java int array with a given size, the array is filled with 0's\nby default and can be filled with only ints\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.intOf(num)": {
    "prefix": "Java.intOf(num)",
    "body": "Java.intOf($num)",
    "description": "Java.intOf(num)\nCreates a Java value int, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java int\n"
  },
  "Static Method Java.longArray(size)": {
    "prefix": "Java.longArray(size)",
    "body": "Java.longArray($size)",
    "description": "Java.longArray(size)\nCreates a Java long array with a given size, the array is filled with 0's\nby default and can be filled with only longs\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.longOf(num)": {
    "prefix": "Java.longOf(num)",
    "body": "Java.longOf($num)",
    "description": "Java.longOf(num)\nCreates a Java value long, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java long\n"
  },
  "Static Method Java.objectArray(size)": {
    "prefix": "Java.objectArray(size)",
    "body": "Java.objectArray($size)",
    "description": "Java.objectArray(size)\nCreates a Java Object array with a given size, the array is filled with null values\nby default and can be filled with any Java values, this array cannot be expanded\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.predicateOf(function)": {
    "prefix": "Java.predicateOf(function)",
    "body": "Java.predicateOf($function)",
    "description": "Java.predicateOf(function)\nCreates a Java Predicate object from a given function\n- Parameter - Function (`function`): the function to be executed, this must have one parameter and must return a boolean\n"
  },
  "Static Method Java.runnableOf(function)": {
    "prefix": "Java.runnableOf(function)",
    "body": "Java.runnableOf($function)",
    "description": "Java.runnableOf(function)\nCreates a Java Runnable object from a given function, this must\nhave no paramters and any return values will be ignored\n- Parameter - Function (`function`): the function to be executed\n"
  },
  "Static Method Java.setStaticField(className, fieldName, newValue)": {
    "prefix": "Java.setStaticField(className, fieldName, newValue)",
    "body": "Java.setStaticField($className, $fieldName, $newValue)",
    "description": "Java.setStaticField(className, fieldName, newValue)\nSets a static field in a Java class with a new value\n- Parameter - String (`className`): the name of the class\n- Parameter - String (`fieldName`): the name of the field\n- Parameter - Object (`newValue`): the new value\n"
  },
  "Static Method Java.shortArray(size)": {
    "prefix": "Java.shortArray(size)",
    "body": "Java.shortArray($size)",
    "description": "Java.shortArray(size)\nCreates a Java short array with a given size, the array is filled with 0's\nby default and can be filled with only shorts\n- Parameter - Number (`size`): the size of the array\n"
  },
  "Static Method Java.shortOf(num)": {
    "prefix": "Java.shortOf(num)",
    "body": "Java.shortOf($num)",
    "description": "Java.shortOf(num)\nCreates a Java value short, to be used in Java\n- Parameter - Number (`num`): the number to convert to a Java short\n"
  },
  "Static Method Java.supplierOf(function)": {
    "prefix": "Java.supplierOf(function)",
    "body": "Java.supplierOf($function)",
    "description": "Java.supplierOf(function)\nCreates a Java Supplier object from a given function\n- Parameter - Function (`function`): the function to be executed, this must have no parameters and must return (supply) a value\n"
  },
  "Static Method Java.valueOf(value)": {
    "prefix": "Java.valueOf(value)",
    "body": "Java.valueOf($value)",
    "description": "Java.valueOf(value)\nConverts any Arucas value into a Java value then wraps it in the Java wrapper and returns it\n- Parameter - Object (`value`): any value to get the Java value of\n"
  },
  "Method <Java>.callMethod(methodName, parameters...)": {
    "prefix": ".callMethod($methodName, $parameters...)",
    "body": ".callMethod($methodName, $parameters...)",
    "description": "<Java>.callMethod(methodName, parameters...)\nThis calls the specified method with the specified parameters, calling the method\nwith this function has no benefits unless you are calling a function that also is\nnative to Arucas. For example `object.copy()` will use the Arucas 'copy' function.\nBut this is extremely rare so almost all of the time you should all the method normally.\n- Parameter - String (`methodName`): the name of the method\n- Parameter - Object (`parameters...`): the parameters to call the method with\n"
  },
  "Method <Java>.getField(fieldName)": {
    "prefix": ".getField($fieldName)",
    "body": ".getField($fieldName)",
    "description": "<Java>.getField(fieldName)\nThis returns the Java wrapped value of the specified field.\nThere is no reason for you to be using this method, it will be removed in future versions\n- Parameter - String (`fieldName`): the name of the field\n"
  },
  "Method <Java>.getMethodDelegate(methodName, parameters)": {
    "prefix": ".getMethodDelegate($methodName, $parameters)",
    "body": ".getMethodDelegate($methodName, $parameters)",
    "description": "<Java>.getMethodDelegate(methodName, parameters)\nThis returns a method delegate for the specified method name and parameters.\nThis should be avoided and replaced with a Arucas function wrapping the call instead.\nFor example: `delegate = (fun() { Java.valueOf('').isBlank(); });`.\nAnother thing to note is that the parameter count parameter is no longer\nused and ignored internally, instead the parameters are calculated when you\ncall the delegate. The parameter remains for backwards compatability.\n- Parameter - String (`methodName`): the name of the method\n- Parameter - Number (`parameters`): the number of parameters\n"
  },
  "Method <Java>.setField(fieldName, value)": {
    "prefix": ".setField($fieldName, $value)",
    "body": ".setField($fieldName, $value)",
    "description": "<Java>.setField(fieldName, value)\nThis sets the specified field to the specified value\nThere is no reason for you to be using this method, it will be removed in future versions\n- Parameter - String (`fieldName`): the name of the field\n- Parameter - Object (`value`): the value to set the field to, the value type must match the type of the field\n"
  },
  "Method <Java>.toArucas()": {
    "prefix": ".toArucas()",
    "body": ".toArucas()",
    "description": "<Java>.toArucas()\nThis converts the Java value to an Arucas Value if possible, this may still\nbe of a Java value if it cannot be converted. For example, Strings, Numbers, Lists\nwill be converted but \n"
  },
  "JavaClass Class": {
    "prefix": "JavaClass",
    "body": "JavaClass",
    "description": "The JavaClass class from util.Internal.\nThis class 'acts' as a Java class. You are able to call this class which\nwill invoke the Java class' constructor, and access and assign the static\nfields of the class. This class cannot be instantiated or extended.\n"
  },
  "Json Class": {
    "prefix": "Json",
    "body": "Json",
    "description": "The Json class from util.Json.\nThis class allows you to create and manipulate JSON objects.\nThis class cannot be instantiated or extended\n"
  },
  "Static Method Json.fromFile(file)": {
    "prefix": "Json.fromFile(file)",
    "body": "Json.fromFile($file)",
    "description": "Json.fromFile(file)\nThis will read a file and parse it into a Json\n- Parameter - File (`file`): the file that you want to parse into a Json\n"
  },
  "Static Method Json.fromList(list)": {
    "prefix": "Json.fromList(list)",
    "body": "Json.fromList($list)",
    "description": "Json.fromList(list)\nThis converts a list into a Json, an important thing to note is that\nany values that are not Numbers, Booleans, Lists, Maps, or Null will use their\ntoString() member to convert them to a string\n- Parameter - List (`list`): the list that you want to parse into a Json\n"
  },
  "Static Method Json.fromMap(map)": {
    "prefix": "Json.fromMap(map)",
    "body": "Json.fromMap($map)",
    "description": "Json.fromMap(map)\nThis converts a map into a Json, an important thing to note is that\nany values that are not Numbers, Booleans, Lists, Maps, or Null will use their\ntoString() member to convert them to a string\n- Parameter - Map (`map`): the map that you want to parse into a Json\n"
  },
  "Static Method Json.fromString(string)": {
    "prefix": "Json.fromString(string)",
    "body": "Json.fromString($string)",
    "description": "Json.fromString(string)\nThis converts a string into a Json provided it is formatted correctly,\notherwise throwing an error\n- Parameter - String (`string`): the string that you want to parse into a Json\n"
  },
  "Method <Json>.getValue()": {
    "prefix": ".getValue()",
    "body": ".getValue()",
    "description": "<Json>.getValue()\nThis converts the Json back into an object\n"
  },
  "Method <Json>.writeToFile(file)": {
    "prefix": ".writeToFile($file)",
    "body": ".writeToFile($file)",
    "description": "<Json>.writeToFile(file)\nThis writes the Json to a file\nif the file given is a directory or cannot be\nwritten to, an error will be thrown\n- Parameter - File (`file`): the file that you want to write to\n"
  },
  "List Class": {
    "prefix": "List",
    "body": "List",
    "description": "The List class.\nThis class is used for collections of ordered elements\n"
  },
  "Method <List>.addAll(collection)": {
    "prefix": ".addAll($collection)",
    "body": ".addAll($collection)",
    "description": "<List>.addAll(collection)\nThis allows you to add all the values in another collection to the list\n- Parameter - Collection (`collection`): the collection you want to add to the list\n"
  },
  "Method <List>.append(value)": {
    "prefix": ".append($value)",
    "body": ".append($value)",
    "description": "<List>.append(value)\nThis allows you to append a value to the end of the list\n- Parameter - Object (`value`): the value you want to append\n"
  },
  "Method <List>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<List>.clear()\nThis allows you to clear the list\n"
  },
  "Method <List>.contains(value)": {
    "prefix": ".contains($value)",
    "body": ".contains($value)",
    "description": "<List>.contains(value)\nThis allows you to check if the list contains a specific value\n- Parameter - Object (`value`): the value you want to check\n"
  },
  "Method <List>.containsAll(collection)": {
    "prefix": ".containsAll($collection)",
    "body": ".containsAll($collection)",
    "description": "<List>.containsAll(collection)\nThis allows you to check if the list contains all the values in another collection\n- Parameter - Collection (`collection`): the collection you want to check agains\n"
  },
  "Method <List>.filter(predicate)": {
    "prefix": ".filter($predicate)",
    "body": ".filter($predicate)",
    "description": "<List>.filter(predicate)\nThis filters the list using the predicate, a function that either returns\ntrue or false, based on the element on whether it should be kept or not,\nand returns a new list with the filtered elements\n- Parameter - Function (`predicate`): a function that takes a value and returns Boolean\n"
  },
  "Method <List>.flatten()": {
    "prefix": ".flatten()",
    "body": ".flatten()",
    "description": "<List>.flatten()\nIf there are any objects in the list that are collections they will\nbe expanded and added to the list. However collections inside those\ncollections will not be flattened, this is returned as a new list\n"
  },
  "Method <List>.get(index)": {
    "prefix": ".get($index)",
    "body": ".get($index)",
    "description": "<List>.get(index)\nThis allows you to get the value at a specific index, alternative to bracket accessor,\nthis will throw an error if the index given is out of bounds\n- Parameter - Number (`index`): the index of the value you want to get\n"
  },
  "Method <List>.indexOf(value)": {
    "prefix": ".indexOf($value)",
    "body": ".indexOf($value)",
    "description": "<List>.indexOf(value)\nThis allows you to get the index of a specific value\n- Parameter - Object (`value`): the value you want to get the index of\n"
  },
  "Method <List>.insert(value, index)": {
    "prefix": ".insert($value, $index)",
    "body": ".insert($value, $index)",
    "description": "<List>.insert(value, index)\nThis allows you to insert a value at a specific index, this will throw an error if the index is out of bounds\n- Parameter - Object (`value`): the value you want to insert\n- Parameter - Number (`index`): the index you want to insert the value at\n"
  },
  "Method <List>.lastIndexOf(value)": {
    "prefix": ".lastIndexOf($value)",
    "body": ".lastIndexOf($value)",
    "description": "<List>.lastIndexOf(value)\nThis allows you to get the last index of a specific value\n- Parameter - Object (`value`): the value you want to get the last index of\n"
  },
  "Method <List>.map(mapper)": {
    "prefix": ".map($mapper)",
    "body": ".map($mapper)",
    "description": "<List>.map(mapper)\nThis maps the list using the mapper, a function that takes a value and\nreturns a new value, and returns a new list with the mapped elements\n- Parameter - Function (`mapper`): a function that takes a value and returns a new value\n"
  },
  "Method <List>.prepend(value)": {
    "prefix": ".prepend($value)",
    "body": ".prepend($value)",
    "description": "<List>.prepend(value)\nThis allows you to prepend a value to the beginning of the list\n- Parameter - Object (`value`): the value you want to prepend\n"
  },
  "Method <List>.reduce(reducer)": {
    "prefix": ".reduce($reducer)",
    "body": ".reduce($reducer)",
    "description": "<List>.reduce(reducer)\nThis reduces the list using the reducer, a function that takes an\naccumulated value and a new value and returns the next accumulated value\n- Parameter - Function (`reducer`): a function that takes a value and returns a new value\n"
  },
  "Method <List>.remove(index)": {
    "prefix": ".remove($index)",
    "body": ".remove($index)",
    "description": "<List>.remove(index)\nThis allows you to remove the value at a specific index, alternative to bracket assignment.\nThis will throw an error if the index is out of bounds\n- Parameter - Number (`index`): the index of the value you want to remove\n"
  },
  "Method <List>.removeAll(collection)": {
    "prefix": ".removeAll($collection)",
    "body": ".removeAll($collection)",
    "description": "<List>.removeAll(collection)\nThis allows you to remove all the values in another collection from the list\n- Parameter - Collection (`collection`): the collection you want to remove from the list\n"
  },
  "Method <List>.retainAll(list)": {
    "prefix": ".retainAll($list)",
    "body": ".retainAll($list)",
    "description": "<List>.retainAll(list)\nThis allows you to retain only the values that are in both lists\n- Parameter - List (`list`): the list you want to retain values from\n"
  },
  "Method <List>.reverse()": {
    "prefix": ".reverse()",
    "body": ".reverse()",
    "description": "<List>.reverse()\nThis allows you to reverse the list\n"
  },
  "Method <List>.set(value, index)": {
    "prefix": ".set($value, $index)",
    "body": ".set($value, $index)",
    "description": "<List>.set(value, index)\nThis allows you to set the value at a specific index, alternative to bracket assignment,\nthis will throw an erroor if the index given is out of bounds\n- Parameter - Object (`value`): the value you want to set\n- Parameter - Number (`index`): the index you want to set the value at\n"
  },
  "Method <List>.shuffle()": {
    "prefix": ".shuffle()",
    "body": ".shuffle()",
    "description": "<List>.shuffle()\nThis allows you to shuffle the list\n"
  },
  "Method <List>.sort()": {
    "prefix": ".sort()",
    "body": ".sort()",
    "description": "<List>.sort()\nThis allows you to sort the list using the elements compare method\n"
  },
  "Method <List>.sort(comparator)": {
    "prefix": ".sort($comparator)",
    "body": ".sort($comparator)",
    "description": "<List>.sort(comparator)\nThis allows you to sort the list using a comparator function\n- Parameter - Function (`comparator`): the comparator function\n"
  },
  "Map Class": {
    "prefix": "Map",
    "body": "Map",
    "description": "The Map class.\nThis class is used to create a map of objects, using keys and values.\nThis class cannot be directly instantiated, but can be extended to create a map of your own type.\n"
  },
  "Static Method Map.unordered()": {
    "prefix": "Map.unordered()",
    "body": "Map.unordered()",
    "description": "Map.unordered()\nThis function allows you to create an unordered map\n"
  },
  "Method <Map>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<Map>.clear()\nThis allows you to clear the map of all the keys and values\n"
  },
  "Method <Map>.containsKey(key)": {
    "prefix": ".containsKey($key)",
    "body": ".containsKey($key)",
    "description": "<Map>.containsKey(key)\nThis allows you to check if the map contains a specific key\n- Parameter - Object (`key`): the key you want to check\n"
  },
  "Method <Map>.containsValue(value)": {
    "prefix": ".containsValue($value)",
    "body": ".containsValue($value)",
    "description": "<Map>.containsValue(value)\nThis allows you to check if the map contains a specific value\n- Parameter - Object (`value`): the value you want to check\n"
  },
  "Method <Map>.get(key)": {
    "prefix": ".get($key)",
    "body": ".get($key)",
    "description": "<Map>.get(key)\nThis allows you to get the value of a key in the map\n- Parameter - Object (`key`): the key you want to get the value of\n"
  },
  "Method <Map>.getKeys()": {
    "prefix": ".getKeys()",
    "body": ".getKeys()",
    "description": "<Map>.getKeys()\nThis allows you to get the keys in the map\n"
  },
  "Method <Map>.getValues()": {
    "prefix": ".getValues()",
    "body": ".getValues()",
    "description": "<Map>.getValues()\nThis allows you to get the values in the map\n"
  },
  "Method <Map>.map(remapper)": {
    "prefix": ".map($remapper)",
    "body": ".map($remapper)",
    "description": "<Map>.map(remapper)\nThis allows you to map the values in the map and returns a new map\n- Parameter - Function (`remapper`): the function you want to map the values with\n"
  },
  "Method <Map>.put(key, value)": {
    "prefix": ".put($key, $value)",
    "body": ".put($key, $value)",
    "description": "<Map>.put(key, value)\nThis allows you to put a key and value in the map\n- Parameter - Object (`key`): the key you want to put\n- Parameter - Object (`value`): the value you want to put\n"
  },
  "Method <Map>.putAll(another map)": {
    "prefix": ".putAll($another map)",
    "body": ".putAll($another map)",
    "description": "<Map>.putAll(another map)\nThis allows you to put all the keys and values of another map into this map\n- Parameter - Map (`another map`): the map you want to merge into this map\n"
  },
  "Method <Map>.putIfAbsent(key, value)": {
    "prefix": ".putIfAbsent($key, $value)",
    "body": ".putIfAbsent($key, $value)",
    "description": "<Map>.putIfAbsent(key, value)\nThis allows you to put a key and value in the map if it doesn't exist\n- Parameter - Object (`key`): the key you want to put\n- Parameter - Object (`value`): the value you want to put\n"
  },
  "Method <Map>.remove(key)": {
    "prefix": ".remove($key)",
    "body": ".remove($key)",
    "description": "<Map>.remove(key)\nThis allows you to remove a key and its value from the map\n- Parameter - Object (`key`): the key you want to remove\n"
  },
  "Math Class": {
    "prefix": "Math",
    "body": "Math",
    "description": "The Math class.\nProvides many basic math functions. This is a utility class, and cannot be constructed\n"
  },
  "Static Field Math.e": {
    "prefix": "Math.e",
    "body": "Math.e",
    "description": "Math.e\nThe value of e"
  },
  "Static Field Math.pi": {
    "prefix": "Math.pi",
    "body": "Math.pi",
    "description": "Math.pi\nThe value of pi"
  },
  "Static Field Math.root2": {
    "prefix": "Math.root2",
    "body": "Math.root2",
    "description": "Math.root2\nThe value of root 2"
  },
  "Static Method Math.abs(num)": {
    "prefix": "Math.abs(num)",
    "body": "Math.abs($num)",
    "description": "Math.abs(num)\nReturns the absolute value of a number\n- Parameter - Number (`num`): the number to get the absolute value of\n"
  },
  "Static Method Math.arccos(num)": {
    "prefix": "Math.arccos(num)",
    "body": "Math.arccos($num)",
    "description": "Math.arccos(num)\nReturns the arc cosine of a number\n- Parameter - Number (`num`): the number to get the arc cosine of\n"
  },
  "Static Method Math.arcsin(num)": {
    "prefix": "Math.arcsin(num)",
    "body": "Math.arcsin($num)",
    "description": "Math.arcsin(num)\nReturns the arc sine of a number\n- Parameter - Number (`num`): the number to get the arc sine of\n"
  },
  "Static Method Math.arctan(num)": {
    "prefix": "Math.arctan(num)",
    "body": "Math.arctan($num)",
    "description": "Math.arctan(num)\nReturns the arc tangent of a number\n- Parameter - Number (`num`): the number to get the arc tangent of\n"
  },
  "Static Method Math.arctan2(y, x)": {
    "prefix": "Math.arctan2(y, x)",
    "body": "Math.arctan2($y, $x)",
    "description": "Math.arctan2(y, x)\nReturns the angle theta of the polar coordinates (r, theta) that correspond to the rectangular\ncoordinates (x, y) by computing the arc tangent of the value y / x\n- Parameter - Number (`y`): the ordinate coordinate\n- Parameter - Number (`x`): the abscissa coordinate\n"
  },
  "Static Method Math.ceil(num)": {
    "prefix": "Math.ceil(num)",
    "body": "Math.ceil($num)",
    "description": "Math.ceil(num)\nRounds a number up to the nearest integer\n- Parameter - Number (`num`): the number to round\n"
  },
  "Static Method Math.clamp(value, min, max)": {
    "prefix": "Math.clamp(value, min, max)",
    "body": "Math.clamp($value, $min, $max)",
    "description": "Math.clamp(value, min, max)\nClamps a value between a minimum and maximum\n- Parameter - Number (`value`): the value to clamp\n- Parameter - Number (`min`): the minimum\n- Parameter - Number (`max`): the maximum\n"
  },
  "Static Method Math.cos(num)": {
    "prefix": "Math.cos(num)",
    "body": "Math.cos($num)",
    "description": "Math.cos(num)\nReturns the cosine of a number\n- Parameter - Number (`num`): the number to get the cosine of\n"
  },
  "Static Method Math.cosec(num)": {
    "prefix": "Math.cosec(num)",
    "body": "Math.cosec($num)",
    "description": "Math.cosec(num)\nReturns the cosecant of a number\n- Parameter - Number (`num`): the number to get the cosecant of\n"
  },
  "Static Method Math.cosh(num)": {
    "prefix": "Math.cosh(num)",
    "body": "Math.cosh($num)",
    "description": "Math.cosh(num)\nReturns the hyperbolic cosine of a number\n- Parameter - Number (`num`): the number to get the hyperbolic cosine of\n"
  },
  "Static Method Math.cot(num)": {
    "prefix": "Math.cot(num)",
    "body": "Math.cot($num)",
    "description": "Math.cot(num)\nReturns the cotangent of a number\n- Parameter - Number (`num`): the number to get the cotangent of\n"
  },
  "Static Method Math.floor(num)": {
    "prefix": "Math.floor(num)",
    "body": "Math.floor($num)",
    "description": "Math.floor(num)\nRounds a number down to the nearest integer\n- Parameter - Number (`num`): the number to round\n"
  },
  "Static Method Math.lerp(start, end, delta)": {
    "prefix": "Math.lerp(start, end, delta)",
    "body": "Math.lerp($start, $end, $delta)",
    "description": "Math.lerp(start, end, delta)\nLinear interpolation between two numbers\n- Parameter - Number (`start`): the first number\n- Parameter - Number (`end`): the second number\n- Parameter - Number (`delta`): the interpolation factor\n"
  },
  "Static Method Math.ln(num)": {
    "prefix": "Math.ln(num)",
    "body": "Math.ln($num)",
    "description": "Math.ln(num)\nReturns the natural logarithm of a number\n- Parameter - Number (`num`): the number to get the logarithm of\n"
  },
  "Static Method Math.log(base, num)": {
    "prefix": "Math.log(base, num)",
    "body": "Math.log($base, $num)",
    "description": "Math.log(base, num)\nReturns the logarithm of a number with a specified base\n- Parameter - Number (`base`): the base\n- Parameter - Number (`num`): the number to get the logarithm of\n"
  },
  "Static Method Math.log10(num)": {
    "prefix": "Math.log10(num)",
    "body": "Math.log10($num)",
    "description": "Math.log10(num)\nReturns the base 10 logarithm of a number\n- Parameter - Number (`num`): the number to get the logarithm of\n"
  },
  "Static Method Math.max(num1, num2)": {
    "prefix": "Math.max(num1, num2)",
    "body": "Math.max($num1, $num2)",
    "description": "Math.max(num1, num2)\nReturns the largest number\n- Parameter - Number (`num1`): the first number to compare\n- Parameter - Number (`num2`): the second number to compare\n"
  },
  "Static Method Math.min(num1, num2)": {
    "prefix": "Math.min(num1, num2)",
    "body": "Math.min($num1, $num2)",
    "description": "Math.min(num1, num2)\nReturns the smallest number\n- Parameter - Number (`num1`): the first number to compare\n- Parameter - Number (`num2`): the second number to compare\n"
  },
  "Static Method Math.mod(num1, num2)": {
    "prefix": "Math.mod(num1, num2)",
    "body": "Math.mod($num1, $num2)",
    "description": "Math.mod(num1, num2)\nReturns the modulus of a division\n- Parameter - Number (`num1`): the number to divide\n- Parameter - Number (`num2`): the divisor\n"
  },
  "Static Method Math.rem(num1, num2)": {
    "prefix": "Math.rem(num1, num2)",
    "body": "Math.rem($num1, $num2)",
    "description": "Math.rem(num1, num2)\nReturns the remainder of a division\n- Parameter - Number (`num1`): the number to divide\n- Parameter - Number (`num2`): the divisor\n"
  },
  "Static Method Math.round(num)": {
    "prefix": "Math.round(num)",
    "body": "Math.round($num)",
    "description": "Math.round(num)\nRounds a number to the nearest integer\n- Parameter - Number (`num`): the number to round\n"
  },
  "Static Method Math.sec(num)": {
    "prefix": "Math.sec(num)",
    "body": "Math.sec($num)",
    "description": "Math.sec(num)\nReturns the secant of a number\n- Parameter - Number (`num`): the number to get the secant of\n"
  },
  "Static Method Math.signum(num)": {
    "prefix": "Math.signum(num)",
    "body": "Math.signum($num)",
    "description": "Math.signum(num)\nReturns the sign of a number, 1 if the number is positive,\n-1 if the number is negative, and 0 if the number is 0\n- Parameter - Number (`num`): the number to get the sign of\n"
  },
  "Static Method Math.sin(num)": {
    "prefix": "Math.sin(num)",
    "body": "Math.sin($num)",
    "description": "Math.sin(num)\nReturns the sine of a number\n- Parameter - Number (`num`): the number to get the sine of\n"
  },
  "Static Method Math.sinh(num)": {
    "prefix": "Math.sinh(num)",
    "body": "Math.sinh($num)",
    "description": "Math.sinh(num)\nReturns the hyperbolic sine of a number\n- Parameter - Number (`num`): the number to get the hyperbolic sine of\n"
  },
  "Static Method Math.sqrt(num)": {
    "prefix": "Math.sqrt(num)",
    "body": "Math.sqrt($num)",
    "description": "Math.sqrt(num)\nReturns the square root of a number\n- Parameter - Number (`num`): the number to square root\n"
  },
  "Static Method Math.tan(num)": {
    "prefix": "Math.tan(num)",
    "body": "Math.tan($num)",
    "description": "Math.tan(num)\nReturns the tangent of a number\n- Parameter - Number (`num`): the number to get the tangent of\n"
  },
  "Static Method Math.tanh(num)": {
    "prefix": "Math.tanh(num)",
    "body": "Math.tanh($num)",
    "description": "Math.tanh(num)\nReturns the hyperbolic tangent of a number\n- Parameter - Number (`num`): the number to get the hyperbolic tangent of\n"
  },
  "Static Method Math.toDegrees(num)": {
    "prefix": "Math.toDegrees(num)",
    "body": "Math.toDegrees($num)",
    "description": "Math.toDegrees(num)\nConverts a number from radians to degrees\n- Parameter - Number (`num`): the number to convert\n"
  },
  "Static Method Math.toRadians(num)": {
    "prefix": "Math.toRadians(num)",
    "body": "Math.toRadians($num)",
    "description": "Math.toRadians(num)\nConverts a number from degrees to radians\n- Parameter - Number (`num`): the number to convert\n"
  },
  "Network Class": {
    "prefix": "Network",
    "body": "Network",
    "description": "The Network class from util.Network.\nAllows you to do http requests. This is a utility class and cannot be constructed.\n"
  },
  "Static Method Network.downloadFile(url, file)": {
    "prefix": "Network.downloadFile(url, file)",
    "body": "Network.downloadFile($url, $file)",
    "description": "Network.downloadFile(url, file)\nDownloads a file from an url to a file\n- Parameter - String (`url`): the url to download from\n- Parameter - File (`file`): the file to download to\n"
  },
  "Static Method Network.openUrl(url)": {
    "prefix": "Network.openUrl(url)",
    "body": "Network.openUrl($url)",
    "description": "Network.openUrl(url)\nOpens an url in the default browser\n- Parameter - String (`url`): the url to open\n"
  },
  "Static Method Network.requestUrl(url)": {
    "prefix": "Network.requestUrl(url)",
    "body": "Network.requestUrl($url)",
    "description": "Network.requestUrl(url)\nRequests an url and returns the response\n- Parameter - String (`url`): the url to request\n"
  },
  "Null Class": {
    "prefix": "Null",
    "body": "Null",
    "description": "The Null class.\nThis class is used for the null object,\nthis cannot be instantiated or extended\n"
  },
  "Number Class": {
    "prefix": "Number",
    "body": "Number",
    "description": "The Number class.\nThis class cannot be constructed as it has a literal representation.\nFor math related functions see the Math class.\n"
  },
  "Method <Number>.ceil()": {
    "prefix": ".ceil()",
    "body": ".ceil()",
    "description": "<Number>.ceil()\nThis allows you to round a number up to the nearest integer\n"
  },
  "Method <Number>.floor()": {
    "prefix": ".floor()",
    "body": ".floor()",
    "description": "<Number>.floor()\nThis allows you to round a number down to the nearest integer\n"
  },
  "Method <Number>.isInfinite()": {
    "prefix": ".isInfinite()",
    "body": ".isInfinite()",
    "description": "<Number>.isInfinite()\nThis allows you to check if a number is infinite\n"
  },
  "Method <Number>.isNaN()": {
    "prefix": ".isNaN()",
    "body": ".isNaN()",
    "description": "<Number>.isNaN()\nThis allows you to check if a number is not a number\n"
  },
  "Method <Number>.round()": {
    "prefix": ".round()",
    "body": ".round()",
    "description": "<Number>.round()\nThis allows you to round a number to the nearest integer\n"
  },
  "Object Class": {
    "prefix": "Object",
    "body": "Object",
    "description": "The Object class.\nThis is the base class for every other class in Arucas.\nThis class cannot be instantiated from, you can extend it\nhowever every class already extends this class by default\n"
  },
  "Method <Object>.copy()": {
    "prefix": ".copy()",
    "body": ".copy()",
    "description": "<Object>.copy()\nThis returns a copy of the value if implemented.\nSome objects that are immutable, such as Strings and Numbers\nwill not be copied, and will return the same instance.\nAny object that has not implemented the copy method will also\nreturn the same instance\n"
  },
  "Method <Object>.hashCode()": {
    "prefix": ".hashCode()",
    "body": ".hashCode()",
    "description": "<Object>.hashCode()\nThis returns the hash code of the value, mainly used for maps and sets\nthe hash code of an object must remain consistent for objects to be able\nto be used as keys in a map or set. If two objects are equal, they must\nhave the same hash code\n"
  },
  "Method <Object>.instanceOf(type)": {
    "prefix": ".instanceOf($type)",
    "body": ".instanceOf($type)",
    "description": "<Object>.instanceOf(type)\nThis returns true if the value is an instance of the given type\n- Parameter - Type (`type`): the type to check against\n"
  },
  "Method <Object>.toString()": {
    "prefix": ".toString()",
    "body": ".toString()",
    "description": "<Object>.toString()\nThis returns the string representation of the value\n"
  },
  "Method <Object>.uniqueHash()": {
    "prefix": ".uniqueHash()",
    "body": ".uniqueHash()",
    "description": "<Object>.uniqueHash()\nThis returns the unique hash of the value, this is different for every instance of a value\n"
  },
  "Set Class": {
    "prefix": "Set",
    "body": "Set",
    "description": "The Set class.\nSets are collections of unique values. Similar to maps, without the values.\nAn instance of the class can be created by using `Set.of(values...)`\n"
  },
  "Static Method Set.of(values...)": {
    "prefix": "Set.of(values...)",
    "body": "Set.of($values...)",
    "description": "Set.of(values...)\nThis allows you to create a set with an arbitrary number of values\n- Parameter - Object (`values...`): the values you want to add to the set\n"
  },
  "Static Method Set.unordered()": {
    "prefix": "Set.unordered()",
    "body": "Set.unordered()",
    "description": "Set.unordered()\nThis creates an unordered set\n"
  },
  "Method <Set>.add(value)": {
    "prefix": ".add($value)",
    "body": ".add($value)",
    "description": "<Set>.add(value)\nThis allows you to add a value to the set\n- Parameter - Object (`value`): the value you want to add to the set\n"
  },
  "Method <Set>.addAll(collection)": {
    "prefix": ".addAll($collection)",
    "body": ".addAll($collection)",
    "description": "<Set>.addAll(collection)\nThis allows you to add all the values in a collection into the set\n- Parameter - Collection (`collection`): the collection of values you want to add\n"
  },
  "Method <Set>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<Set>.clear()\nThis removes all values from inside the set\n"
  },
  "Method <Set>.contains(value)": {
    "prefix": ".contains($value)",
    "body": ".contains($value)",
    "description": "<Set>.contains(value)\nThis allows you to check whether a value is in the set\n- Parameter - Object (`value`): the value that you want to check in the set\n"
  },
  "Method <Set>.containsAll(collection)": {
    "prefix": ".containsAll($collection)",
    "body": ".containsAll($collection)",
    "description": "<Set>.containsAll(collection)\nThis allows you to check whether a collection of values are all in the set\n- Parameter - Collection (`collection`): the collection of values you want to check in the set\n"
  },
  "Method <Set>.filter(function)": {
    "prefix": ".filter($function)",
    "body": ".filter($function)",
    "description": "<Set>.filter(function)\nThis allows you to filter the set\n- Parameter - Function (`function`): the function you want to filter the set by\n"
  },
  "Method <Set>.get(value)": {
    "prefix": ".get($value)",
    "body": ".get($value)",
    "description": "<Set>.get(value)\nThis allows you to get a value from in the set.\nThe reason this might be useful is if you want to retrieve something\nfrom the set that will have the same hashcode but be in a different state\nas the value you are passing in\n- Parameter - Object (`value`): the value you want to get from the set\n"
  },
  "Method <Set>.map(function)": {
    "prefix": ".map($function)",
    "body": ".map($function)",
    "description": "<Set>.map(function)\nThis allows you to map the set\n- Parameter - Function (`function`): the function you want to map the set by\n"
  },
  "Method <Set>.reduce(function)": {
    "prefix": ".reduce($function)",
    "body": ".reduce($function)",
    "description": "<Set>.reduce(function)\nThis allows you to reduce the set\n- Parameter - Function (`function`): the function you want to reduce the set by\n"
  },
  "Method <Set>.remove(value)": {
    "prefix": ".remove($value)",
    "body": ".remove($value)",
    "description": "<Set>.remove(value)\nThis allows you to remove a value from the set\n- Parameter - Object (`value`): the value you want to remove from the set\n"
  },
  "Method <Set>.removeAll(value)": {
    "prefix": ".removeAll($value)",
    "body": ".removeAll($value)",
    "description": "<Set>.removeAll(value)\nThis allows you to remove all values in a collection from the set\n- Parameter - Collection (`value`): the values you want to remove from the set\n"
  },
  "Method <Set>.toList()": {
    "prefix": ".toList()",
    "body": ".toList()",
    "description": "<Set>.toList()\nThis returns a list of all the values in the set\n"
  },
  "String Class": {
    "prefix": "String",
    "body": "String",
    "description": "The String class.\nThis class represents an array of characters to form a string.\nThis class cannot be instantiated directly, instead use the literal\nby using quotes. Strings are immutable in Arucas.\n"
  },
  "Method <String>.capitalize()": {
    "prefix": ".capitalize()",
    "body": ".capitalize()",
    "description": "<String>.capitalize()\nThis returns the string in capitalized form\n"
  },
  "Method <String>.chars()": {
    "prefix": ".chars()",
    "body": ".chars()",
    "description": "<String>.chars()\nThis makes a list of all the characters in the string\n"
  },
  "Method <String>.contains(string)": {
    "prefix": ".contains($string)",
    "body": ".contains($string)",
    "description": "<String>.contains(string)\nThis returns whether the string contains the given string\n- Parameter - String (`string`): the string to check\n"
  },
  "Method <String>.endsWith(string)": {
    "prefix": ".endsWith($string)",
    "body": ".endsWith($string)",
    "description": "<String>.endsWith(string)\nThis returns whether the string ends with the given string\n- Parameter - String (`string`): the string to check\n"
  },
  "Method <String>.find(regex)": {
    "prefix": ".find($regex)",
    "body": ".find($regex)",
    "description": "<String>.find(regex)\nThis finds all matches of the regex in the string,\nthis does not find groups, for that use `<String>.findGroups(regex)`\n- Parameter - String (`regex`): the regex to search the string with\n"
  },
  "Method <String>.findAll(regex)": {
    "prefix": ".findAll($regex)",
    "body": ".findAll($regex)",
    "description": "<String>.findAll(regex)\nThis finds all matches and groups of a regex in the matches in the string\nthe first group of each match will be the complete match and following\nwill be the groups of the regex, a group may be empty if it doesn't exist\n- Parameter - String (`regex`): the regex to search the string with\n"
  },
  "Method <String>.format(objects...)": {
    "prefix": ".format($objects...)",
    "body": ".format($objects...)",
    "description": "<String>.format(objects...)\nThis formats the string using the given arguments.\nThis internally uses the Java String.format() method.\nFor how to use see here: https://www.javatpoint.com/java-string-format\n- Parameter - Object (`objects...`): the objects to insert\n"
  },
  "Method <String>.length()": {
    "prefix": ".length()",
    "body": ".length()",
    "description": "<String>.length()\nThis returns the length of the string\n"
  },
  "Method <String>.lowercase()": {
    "prefix": ".lowercase()",
    "body": ".lowercase()",
    "description": "<String>.lowercase()\nThis returns the string in lowercase\n"
  },
  "Method <String>.matches(regex)": {
    "prefix": ".matches($regex)",
    "body": ".matches($regex)",
    "description": "<String>.matches(regex)\nThis returns whether the string matches the given regex\n- Parameter - String (`regex`): the regex to match the string with\n"
  },
  "Method <String>.replaceAll(regex, replacement)": {
    "prefix": ".replaceAll($regex, $replacement)",
    "body": ".replaceAll($regex, $replacement)",
    "description": "<String>.replaceAll(regex, replacement)\nThis replaces all the instances of a regex with the replace string\n- Parameter - String (`regex`): the regex you want to replace\n- Parameter - String (`replacement`): the string you want to replace it with\n"
  },
  "Method <String>.replaceFirst(regex, replacement)": {
    "prefix": ".replaceFirst($regex, $replacement)",
    "body": ".replaceFirst($regex, $replacement)",
    "description": "<String>.replaceFirst(regex, replacement)\nThis replaces the first instance of a regex with the replace string\n- Parameter - String (`regex`): the regex you want to replace\n- Parameter - String (`replacement`): the string you want to replace it with\n"
  },
  "Method <String>.reverse()": {
    "prefix": ".reverse()",
    "body": ".reverse()",
    "description": "<String>.reverse()\nThis returns the string in reverse\n"
  },
  "Method <String>.split(regex)": {
    "prefix": ".split($regex)",
    "body": ".split($regex)",
    "description": "<String>.split(regex)\nThis splits the string into a list of strings based on a regex\n- Parameter - String (`regex`): the regex to split the string with\n"
  },
  "Method <String>.startsWith(string)": {
    "prefix": ".startsWith($string)",
    "body": ".startsWith($string)",
    "description": "<String>.startsWith(string)\nThis returns whether the string starts with the given string\n- Parameter - String (`string`): the string to check\n"
  },
  "Method <String>.strip()": {
    "prefix": ".strip()",
    "body": ".strip()",
    "description": "<String>.strip()\nThis strips the whitespace from the string\n"
  },
  "Method <String>.subString(from, to)": {
    "prefix": ".subString($from, $to)",
    "body": ".subString($from, $to)",
    "description": "<String>.subString(from, to)\nThis returns a substring of the string\n- Parameter - Number (`from`): the start index (inclusive)\n- Parameter - Number (`to`): the end index (exclusive)\n"
  },
  "Method <String>.toList()": {
    "prefix": ".toList()",
    "body": ".toList()",
    "description": "<String>.toList()\nThis makes a list of all the characters in the string\n"
  },
  "Method <String>.toNumber()": {
    "prefix": ".toNumber()",
    "body": ".toNumber()",
    "description": "<String>.toNumber()\nThis tries to convert the string to a number.\nThis method can convert hex or denary into numbers.\nIf the string is not a number, it will throw an error\n"
  },
  "Method <String>.uppercase()": {
    "prefix": ".uppercase()",
    "body": ".uppercase()",
    "description": "<String>.uppercase()\nThis returns the string in uppercase\n"
  },
  "Task Class": {
    "prefix": "Task",
    "body": "Task",
    "description": "The Task class.\nThis class is used to create tasks that can be chained and\nrun asynchronously. Tasks can be executed as many times as needed\nand chained tasks will be executed in the order they are created.\n"
  },
  "Method <Task>.loopIf(boolSupplier)": {
    "prefix": ".loopIf($boolSupplier)",
    "body": ".loopIf($boolSupplier)",
    "description": "<Task>.loopIf(boolSupplier)\nThis loops the task, essentially just calling 'task.run', the\ntask will run async from the original task, the loop will continue\nif the function provided returns true\n- Parameter - Function (`boolSupplier`): the function to check if the loop should run\n"
  },
  "Method <Task>.run()": {
    "prefix": ".run()",
    "body": ".run()",
    "description": "<Task>.run()\nThis runs the task asynchronously and returns a future which can be awaited.\nThe last function in the task will be used as the return value for the future\n"
  },
  "Method <Task>.then(function)": {
    "prefix": ".then($function)",
    "body": ".then($function)",
    "description": "<Task>.then(function)\nThis adds a function to the end of the current task.\nIf this is the last function in the task then the return\nvalue of the function will be the return value of the task.\n- Parameter - Function (`function`): the function to run at the end of the task\n"
  },
  "Thread Class": {
    "prefix": "Thread",
    "body": "Thread",
    "description": "The Thread class.\nThis class allows to to create threads for async executions.\nThis class cannot be instantiated or extended. To create a new\nthread use the static method 'Thread.runThreaded()'\n"
  },
  "Static Method Thread.freeze()": {
    "prefix": "Thread.freeze()",
    "body": "Thread.freeze()",
    "description": "Thread.freeze()\nThis freezes the current thread, stops anything else from executing on the thread.\nThis may fail if you try to freeze a non Arucas Thread in which case an error will be thrown\n"
  },
  "Static Method Thread.getCurrentThread()": {
    "prefix": "Thread.getCurrentThread()",
    "body": "Thread.getCurrentThread()",
    "description": "Thread.getCurrentThread()\nThis gets the current thread that the code is running on,\nthis may throw an error if the thread is not safe to get,\nwhich happens when running outside of Arucas Threads\n"
  },
  "Static Method Thread.runThreaded(function)": {
    "prefix": "Thread.runThreaded(function)",
    "body": "Thread.runThreaded($function)",
    "description": "Thread.runThreaded(function)\nThis starts a new thread and runs a function on it, the thread will\nterminate when it finishes executing the function, threads will stop automatically\nwhen the program stops, you are also able to stop threads by using the Thread object\n- Parameter - Function (`function`): the function you want to run on a new thread\n"
  },
  "Static Method Thread.runThreaded(name, function)": {
    "prefix": "Thread.runThreaded(name, function)",
    "body": "Thread.runThreaded($name, $function)",
    "description": "Thread.runThreaded(name, function)\nThis starts a new thread with a specific name and runs a function on it\n- Parameter - String (`name`): the name of the thread\n- Parameter - Function (`function`): the function you want to run on a new thread\n"
  },
  "Method <Thread>.freeze()": {
    "prefix": ".freeze()",
    "body": ".freeze()",
    "description": "<Thread>.freeze()\nThis serves the same purpose as 'Thread.freeze()' however this works on the current\nthread instance, unlike 'Thread.freeze()' this cannot throw an error.\n"
  },
  "Method <Thread>.getAge()": {
    "prefix": ".getAge()",
    "body": ".getAge()",
    "description": "<Thread>.getAge()\nThis gets the age of the thread in milliseconds\n"
  },
  "Method <Thread>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Thread>.getName()\nThis gets the name of the thread\n"
  },
  "Method <Thread>.isAlive()": {
    "prefix": ".isAlive()",
    "body": ".isAlive()",
    "description": "<Thread>.isAlive()\nThis checks if the thread is alive (still running)\n"
  },
  "Method <Thread>.stop()": {
    "prefix": ".stop()",
    "body": ".stop()",
    "description": "<Thread>.stop()\nThis stops the thread from executing, anything that was running will be instantly stopped.\nThis method will fail if the thread is not alive\n"
  },
  "Method <Thread>.thaw()": {
    "prefix": ".thaw()",
    "body": ".thaw()",
    "description": "<Thread>.thaw()\nThis will thaw the thread from its frozen state, if the thread is not frozen then an\nerror will be thrown\n"
  },
  "Type Class": {
    "prefix": "Type",
    "body": "Type",
    "description": "The Type class.\nThis class lets you get the type of another class\n"
  },
  "Static Method Type.of(value)": {
    "prefix": "Type.of(value)",
    "body": "Type.of($value)",
    "description": "Type.of(value)\nThis gets the specific type of a value\n- Parameter - Object (`value`): the value you want to get the type of\n"
  },
  "Method <Type>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Type>.getName()\nThis gets the name of the type\n"
  },
  "Method <Type>.inheritsFrom(type)": {
    "prefix": ".inheritsFrom($type)",
    "body": ".inheritsFrom($type)",
    "description": "<Type>.inheritsFrom(type)\nThis checks whether a type is a subtype of another type\n- Parameter - Type (`type`): the other type you want to check against\n"
  },
  "Method <Type>.instanceOf(type)": {
    "prefix": ".instanceOf($type)",
    "body": ".instanceOf($type)",
    "description": "<Type>.instanceOf(type)\nThis checks whether a type is a subtype of another type\n- Parameter - Type (`type`): the other type you want to check against\n"
  }
}